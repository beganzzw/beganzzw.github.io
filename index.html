<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>began个人博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="学习笔记">
<meta property="og:type" content="website">
<meta property="og:title" content="began个人博客">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="began个人博客">
<meta property="og:description" content="学习笔记">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="zzw">
<meta property="article:tag" content="笔记">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="began个人博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">began个人博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-typescript-day03" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/01/18/typescript-day03/" class="article-date">
  <time datetime="2022-01-18T07:15:46.000Z" itemprop="datePublished">2022-01-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/01/18/typescript-day03/">typescript-day03</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><h2 id="接口初探"><a href="#接口初探" class="headerlink" title="接口初探"></a>接口初探</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function printLabel(labelledObj: &#123; label: string&#125;) &#123;</span><br><span class="line">  console.log(labelledObj.label);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let myObj = &#123; size: 10, label: &quot;size 10 Object&quot; &#125;;</span><br><span class="line">printLabel(myObj);</span><br></pre></td></tr></table></figure>
<p>类型检查器会查看<code>printLabel</code>的调用。<code>printLabel</code>有一个参数,并要求这个对象参数有一个名为<code>label</code>类型为<code>string</code>的属性。需要注意的是，我们传入的对象参数实际上会包含很多属性,但是编译器只会检查哪些必须的属性是否存在，并且其类型是否匹配。</p>
<p>下面我们重写上面的例子，这次试用接口来描述：必须包含一个<code>label</code>属性且类型为<code>string</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interface LabelledValue &#123;</span><br><span class="line">  label: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function printLabel(labelledObj: LabelledValue) &#123;</span><br><span class="line">  console.log(labelledObj.label);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let myObj = &#123; size: 10, label: &quot;Size 10 Object&quot;&#125;;</span><br><span class="line">printLabel(myObj);</span><br></pre></td></tr></table></figure>
<p><code>LabelledValue</code>接口就好比一个名字，用来描述上面例子里的要求。它代表了有一个<code>label</code>属性且类型为<code>string</code>的对象。需要注意的是,我们在这里并不能像在其他语言里一样，说传给<code>printLabel</code>的对象实现了这个接口。我们只会去关注值的外形。只要传入的对象满足上面提到的必要条件，那么它就是被允许的。</p>
<p>还有一点值得提的是，类型检查器不会去检查属性的顺序，只要相应的属性存在并且也是对的就可以。</p>
<h2 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h2><p>接口里的属性不全都是必须的。有些是只在某些条件下存在，或者根本不存在。可选属性在应用”option bags”模式时很常用，即给函数传入的参数对象中只有部分属性赋值了。</p>
<p>下面是应用了”option bags”的例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">interface SquareConfig &#123;</span><br><span class="line">  color?: string;</span><br><span class="line">  width?: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function createSquare(config: SquareConfig): &#123;color: string, area: number&#125; &#123;</span><br><span class="line">  let newSquare - &#123;color: &quot;white&quot;, area: 100&#125;;</span><br><span class="line">  if (config.color) &#123;</span><br><span class="line">    newSquare.color = config.color;</span><br><span class="line">  &#125;</span><br><span class="line">  if (config.width) &#123;</span><br><span class="line">    newSquare.area = config.width * config.width;</span><br><span class="line">  &#125;</span><br><span class="line">  return newSquare;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let mySquare = createSquare(&#123;color: &quot;black&quot;&#125;)</span><br></pre></td></tr></table></figure>
<p>带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个<code>?</code>符号。</p>
<p>可选属性的好处之一是对可能存在的属性进行预定义，好处之二是可以捕获引用了不存在属性时的错误。</p>
<h2 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h2><p>一些对象属性只能在对象刚刚创建的时候修改其值。你可以在属性名前用<code>readonly</code>来指定只读属性；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface Point &#123;</span><br><span class="line">  readonly x: number;</span><br><span class="line">  readonly y: number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以通过赋值一个对象字面量来构造一个<code>Point</code>，赋值后，<code>x</code>和<code>y</code>再也不能改变了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let p1:Ponit = &#123;x: 10, y: 20&#125;;</span><br><span class="line">p1.x = 5 // Error</span><br></pre></td></tr></table></figure>
<p>TypeScript 具有 <code>ReadonlyArray&lt;T&gt;</code> 类型，它与<code>Array&lt;T&gt;</code>相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改；</p>
<h3 id="readonly-VS-const"><a href="#readonly-VS-const" class="headerlink" title="readonly VS const"></a><code>readonly</code> VS <code>const</code></h3><p>最简单判断该用  <code>readonly</code>还是<code>const</code>的方法是看要把它做为变量使用还是作为一个属性。做为变量使用的话用<code>const</code>，若做为属性使用<code>readonly</code>。</p>
<h2 id="额外的属性检查"><a href="#额外的属性检查" class="headerlink" title="额外的属性检查"></a>额外的属性检查</h2><p>我们在第一个例子里使用了接口，TypeScript让我们传入<code>&#123; size: number, label: string&#125;</code>到仅期望得到<code>&#123;label: string&#125;</code>的函数里。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">interface SquareConfig &#123;</span><br><span class="line">  color?: string;</span><br><span class="line">  width?: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function createSquare(config: SquareConfig): &#123;color: string; area: number&#125; &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// error： &quot;color&quot; not expected in type &quot;SquareConfig&quot;</span><br><span class="line">let mySquare = createSquare(&#123; colour: &quot;red&quot;, width: 100&#125;);</span><br></pre></td></tr></table></figure>
<p>注意传入<code>createSquare</code>的参数拼写为<code>colour</code>而不是<code>color</code>。在JavaScrit里，这会失败。</p>
<p>最佳的方式是能添加一个字符串索引签名，前提是你能够确定这个对象可能具有某些做为特殊用途使用的额外属性。如果<code>SquareConfig</code>带有上面定义的类型<code>color</code>和<code>width</code>属性，并且还会带有任意数量的其他属性，那么我们可以这样定义它：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface SquareConfig &#123;</span><br><span class="line">  color?: string;</span><br><span class="line">  width?: number;</span><br><span class="line">  [propName: string]: any;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h2><p>接口能够描述JavaScript中对象拥有的各种各样的外形。除了描述带有属性的普通对象外，接口也可以描述函数类型。</p>
<p>为了使用接口表示函数类型，我们需要给接口定义一个调用签名。它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface SearchFunc &#123;</span><br><span class="line">  &#123;source: string, subString: string&#125;: boolean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样定义后，我们可以像使用其他接口一样使用这个函数类型的接口。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let mySearch: SearchFunc;</span><br><span class="line">mySearch = function (source: string, subString: string) &#123;</span><br><span class="line">  let result = source.search(subString);</span><br><span class="line">  return result &gt; -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于函数类型的类型检查来说，函数的参数名不需要与接口里定义的名字相匹配。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let mySearch:SearchFunc;</span><br><span class="line">mySearch = function(src: string, sub: string): boolean &#123;</span><br><span class="line">  let result = src.serach(sub);</span><br><span class="line">  return result &gt; -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数的参数会逐个进行检查，要求对应位置上的参数类型是兼容的。如果你不想指定类型，TypeScript的类型系统会推断出参数类型，因为函数直接赋值给了<code>SearchFunc</code>类型变量。函数的返回值类型是通过其返回值推断出来的(此例是<code>false</code>和<code>true</code>)。如果让这个函数返回数字或字符串，类型检查器会警告我们函数的返回值类型与<code>SearchFunc</code>接口中的定义不匹配。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let mySearch: SearchFunc;</span><br><span class="line">mySearch = function(src, sub) &#123;</span><br><span class="line">  let result = src.search(sub);</span><br><span class="line">  return result &gt; -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="可索引的类型"><a href="#可索引的类型" class="headerlink" title="可索引的类型"></a>可索引的类型</h2><p>与使用接口描述函数类型差不多，我们也可以描述那些能够“通过索引得到”的类型，比如<code>a[10]</code>或<code>ageMap[&quot;daniel&quot;]</code>.可索引类型具有一个索引标签，它描述了对象索引的类型，还有相应的索引返回值类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface StringArray &#123;</span><br><span class="line">  [index: number]: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let myArray: StringArray;</span><br><span class="line">myArray = [&quot;Bob&quot;, &quot;Fred&quot;];</span><br><span class="line"></span><br><span class="line">let myStr: string = myArray[0];</span><br></pre></td></tr></table></figure>
<p>上面例子里，我们定义了<code>StringArray</code>接口,它具有索引签名。这个索引签名表示了当用<code>number</code>去索引<code>StringArray</code>时会得到<code>string</code>类型的返回值.</p>
<p>TypeScript支持两种索引签名:字符串和数字。可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。这是因为当使用<code>number</code>来索引时，JavaScript会将它转换成<code>string</code>然后再去索引对象。也就是说用<code>100</code>(一个<code>number</code>)去索引等同于使用<code>&quot;100&quot;</code>（一个<code>string</code>）去索引，因此两者需要保持一致。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">  name: string;</span><br><span class="line">&#125;</span><br><span class="line">class Dog extends Animal &#123;</span><br><span class="line">  breed: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 错误：使用数值型的字符串索引，有时会得到完全不用的Animal</span><br><span class="line">interface NotOkay &#123;</span><br><span class="line">  [x: number]: Animal;</span><br><span class="line">  [x: string]: Dog;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>字符串索引签名能够很好的描述<code>dictionary</code>模式，并且它们也会确保所有属性与其返回值类型相匹配。因为字符串索引声明了<code>obj.property</code>和<code>obj[&quot;property&quot;]</code>两种形式都可以。下面的例子里，<code>name</code>的类型与字符串索引类型不匹配，所以类型检查器给出一个错误提示:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface NumberDictionary &#123;</span><br><span class="line">  [index: string]: number;</span><br><span class="line">  length: number; // 可以,length是number类型</span><br><span class="line">  name: string    // 错误 &#x27;name&#x27;的类型与索引类型返回值的类型不匹配</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最后，你可以将索引签名设置为只读，这样就防止了给索引赋值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface ReadonlyStringArray &#123;</span><br><span class="line">  readonly [index: number]: string;</span><br><span class="line">&#125;</span><br><span class="line">let myArray: ReadonlyStringArray = [&#x27;Alice&#x27;, &#x27;Bob&#x27;];</span><br><span class="line">myArray[2] = &#x27;Mallory&#x27; // Error</span><br></pre></td></tr></table></figure>
<p>你不能设置<code>myArray[2]</code>,因为索引签名是只读的.</p>
<h2 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h2><h3 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h3><p>与C#或者Java里接口的基本作用一样，TypeScript也能够用它来明确的强制一个类去符合某种契约</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface ClockInterface &#123;</span><br><span class="line">  currentTime: Date;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Clock implements ClockInterface &#123;</span><br><span class="line">  currentTime: Date;</span><br><span class="line">  constructor(h: number, m: number) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你也可以在接口中描述一个方法，在类里实现它，如同下面的<code>setTime</code>方法一样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">interface ClockInterface &#123;</span><br><span class="line">  currentTime: Date;</span><br><span class="line">  setTime(d: Date);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Clock implements ClockInterface &#123;</span><br><span class="line">  currentTime: Date;</span><br><span class="line">  setTime(d: Date) &#123;</span><br><span class="line">    this.currentTime = d;</span><br><span class="line">  &#125;</span><br><span class="line">  constructor(h: number, m: number) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口描述了类的公共部分，而不是公共和私有两部分。它不会帮你检查类是否具有某些私有成员。</p>
<h3 id="类静态部分与实例部分的区别"><a href="#类静态部分与实例部分的区别" class="headerlink" title="类静态部分与实例部分的区别"></a>类静态部分与实例部分的区别</h3><p>当你操作类和接口的时候，你要知道类是具有两个类型的；静态部分的类型和实例的类型，当你用构造器签名去定义一个接口并试图定义一个类去实现这个接口时会得到一个错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface ClockConstructor &#123;</span><br><span class="line">  new (hour: number, minute: number);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Clock implements ClockConstructor &#123;</span><br><span class="line">  currentTime: Date;</span><br><span class="line">  constructor(h: number, m: number) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里因为当一个类实现了一个接口时，只对其实例部分进行类型检查。constructor存在与类的静态部分，所以不再检查的范围内。</p>
<p>因此，我们应该直接操作类的静态部分。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">interface ClockConstructor &#123;</span><br><span class="line">  new (hour: number, minute: number): ClockInterface;</span><br><span class="line">&#125;</span><br><span class="line">interface ClockInterface &#123;</span><br><span class="line">  tick()</span><br><span class="line">&#125;</span><br><span class="line">function createClock (ctor: ClockConstructor, hour: number, minute: number): ClockInterface &#123;</span><br><span class="line">  return new ctor(hour, minute);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class DigtalClock implements ClockInterface &#123;</span><br><span class="line">  constructor(h: number, m: number);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class DigtalClock implements ClockInterface &#123;</span><br><span class="line">  constructor(h: number, m: number);</span><br><span class="line">  tick() &#123;</span><br><span class="line">    console.log(&quot;beep beep&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class AnalogClock implements ClockInterface &#123;</span><br><span class="line">  constructor(h: number, m: number) &#123; &#125;</span><br><span class="line">  tick() &#123;</span><br><span class="line">    console.log(&quot;tick tock&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let digital = createClock(DigtalClock, 12, 17);</span><br><span class="line">let analog = createClock(AnalogClick, 7, 32);</span><br></pre></td></tr></table></figure>
<p>因为<code>createClock</code>的第一个参数是<code>ClockConstructor</code>类型，在<code>createClock(AnalogClock, 7, 32)</code>里，会检查<code>AnalogClock</code>是否符合构造函数签名.</p>
<h2 id="继承接口"><a href="#继承接口" class="headerlink" title="继承接口"></a>继承接口</h2><p>和类一样，接口也可以相互继承。这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活将接口分割到可重用的模块里。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">interface Shape &#123;</span><br><span class="line">  color: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Square extends Shape &#123;</span><br><span class="line">  sideLength: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let square = &lt;Square&gt;();</span><br><span class="line">square.color = &quot;blue&quot;;</span><br><span class="line">square.sideLength = 10;</span><br></pre></td></tr></table></figure>
<p>一个接口可以继承多个接口，创建出多个接口的合成接口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">interface Shape &#123;</span><br><span class="line">  color: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface PenStroke &#123;</span><br><span class="line">  penWidth: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Square extends Shape, PenStroke &#123;</span><br><span class="line">  sideLength: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let square = &lt;Square&gt;();</span><br><span class="line">square.color = &quot;blue&quot;;</span><br><span class="line">square.sideLength = 10;</span><br><span class="line">square.penWidth = 5.0;</span><br></pre></td></tr></table></figure>
<h2 id="混合类型"><a href="#混合类型" class="headerlink" title="混合类型"></a>混合类型</h2><p>一个例子，一个对象可以同时做为函数和对象使用，并带有额外的属性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">interface Counter &#123;</span><br><span class="line">  (start: number): string;</span><br><span class="line">  interval: number;</span><br><span class="line">  reset(): void;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getCount(): Counter &#123;</span><br><span class="line">  let counter = &lt;Counter&gt; function (start: number) &#123; &#125;;</span><br><span class="line">  counter.interval = 22;</span><br><span class="line">  counter.reset = function () &#123; &#125;;</span><br><span class="line">  return counter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let c = getCounter();</span><br><span class="line">c(10);</span><br><span class="line">c.reset();</span><br><span class="line">c.interval = 5.0;</span><br></pre></td></tr></table></figure>
<h2 id="接口继承类"><a href="#接口继承类" class="headerlink" title="接口继承类"></a>接口继承类</h2><p>当接口继承了一个类类型时，它会继承类的成员但不包括实现。就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。接口同样会继承到类的<code>private</code>和<code>proteceed</code>成员。这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现(implement).</p>
<p>当你有一个庞大的继承结构时这很有用，但要指出的是你的代码只在子类拥有特定属性时起作用。这个子类除了继承基类外与基类没有任何关系。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Control &#123;</span><br><span class="line">  private state: any;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface SelectableControl extends Control &#123;</span><br><span class="line">  select(): void;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Button extends Control implements SelectableControl &#123;</span><br><span class="line">  select() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class TextBox extends Control &#123;</span><br><span class="line">  select () &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// error Image 类型缺少 state 属性</span><br><span class="line">class Image implements SelectableControl &#123;</span><br><span class="line">  select() &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Location &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/01/18/typescript-day03/" data-id="ckymdg9lh0002c0t651z29rby" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-typescript-day02" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/01/18/typescript-day02/" class="article-date">
  <time datetime="2022-01-18T06:51:31.000Z" itemprop="datePublished">2022-01-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/01/18/typescript-day02/">typescript-day02</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h1><h2 id="变量声明-1"><a href="#变量声明-1" class="headerlink" title="变量声明"></a>变量声明</h2><p><code>let</code>和<code>const</code>是JavaScript里相对较新的变量声明方式。<code>let</code>在很多方面与<code>var</code>是相似的,但是可以帮助大家避免在JavaScript里常见一些问题。<code>const</code>是对<code>let</code>的一个增强，它能阻止对一个变量再次赋值。</p>
<h2 id="var声明"><a href="#var声明" class="headerlink" title="var声明"></a><code>var</code>声明</h2><p>一直以来我们都是通过<code>var</code>关键字定义JavaScript变量.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">var a = 10;</span><br><span class="line"></span><br><span class="line">function f()&#123;</span><br><span class="line">  var message = &quot;Hello world!&quot;;</span><br><span class="line">  return message;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function f()&#123;</span><br><span class="line">  var a = 10;</span><br><span class="line">  return function g()&#123;</span><br><span class="line">    var b = a + 1;</span><br><span class="line">    return b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var g = f();</span><br><span class="line">g(); // return 11;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function f() &#123;</span><br><span class="line">  var a = 1;</span><br><span class="line">  a = 2;</span><br><span class="line">  var b = g();</span><br><span class="line">  a = 3;</span><br><span class="line">  return b;</span><br><span class="line"></span><br><span class="line">  function g()&#123;</span><br><span class="line">    return a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">f(); // return 2</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="作用域规则"><a href="#作用域规则" class="headerlink" title="作用域规则"></a>作用域规则</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function f(shouldInitialize: boolean) &#123;</span><br><span class="line">  if (shouldInitialize) &#123;</span><br><span class="line">    var x = 10;</span><br><span class="line">  &#125;</span><br><span class="line">  return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(true); // return &#x27;10&#x27;</span><br><span class="line">f(false); // return &#x27;undefined&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="捕获变量怪异之处"><a href="#捕获变量怪异之处" class="headerlink" title="捕获变量怪异之处"></a>捕获变量怪异之处</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">for (var i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">  setTimeout(function () &#123;console.log(i);&#125;, 100 * i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果为:</span><br><span class="line">10</span><br><span class="line">10</span><br><span class="line">10</span><br><span class="line">10</span><br><span class="line">10</span><br><span class="line">10</span><br><span class="line">10</span><br><span class="line">10</span><br><span class="line">10</span><br><span class="line">10</span><br><span class="line"></span><br><span class="line">我们传给setTimeout的每一个函数表达式实际上都引用了相同作用域里的同一个i。</span><br><span class="line">一个通常的解决方案是使用立即执行的函数表达式(IIFE)</span><br><span class="line">for (var i =0; i&lt; 0; i++) &#123;</span><br><span class="line">  (function (i)&#123;</span><br><span class="line">    setTimeout(function() &#123; console.log(i); &#125;, 100 * i)</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="let声明"><a href="#let声明" class="headerlink" title="let声明"></a><code>let</code>声明</h2><h3 id="块作用域"><a href="#块作用域" class="headerlink" title="块作用域"></a>块作用域</h3><p>当用<code>let</code>声明一个变量，它使用的是词法作用域或块作用域.不同于使用<code>var</code>声明的变量那样可以在包含它们的函数外访问，块作用域变量在包含它们块或<code>for</code>循环之外是不能访问的.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function f(input: boolean) &#123;</span><br><span class="line">  let a = 100;</span><br><span class="line">  if (input) &#123;</span><br><span class="line">    let b = a + 1;</span><br><span class="line">    return b;</span><br><span class="line">  &#125;</span><br><span class="line">  return b // Error &#x27;b&#x27; doesn&#x27;t exist here</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>catch</code>语句里声明的变量也具有同样的作用域规则</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">  throw &quot;oh no!&quot;;</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">  console.log(&quot;Oh well&quot;);</span><br><span class="line">&#125;</span><br><span class="line">console.log(e) // Error &#x27;e&#x27; doesn&#x27;t exist here</span><br></pre></td></tr></table></figure>
<p>拥有块级作用域的变量的另一个特点是，它们不能被声明之前读或写。虽然这些变量始终“存在”于它们的作用域里，但在直到声明它的代码之前的区域都属于<strong>暂时性死区</strong></p>
<h3 id="重定义及屏蔽"><a href="#重定义及屏蔽" class="headerlink" title="重定义及屏蔽"></a>重定义及屏蔽</h3><p>我们提过使用<code>var</code>声明时，它不在乎你声明多少次，你只会得到1个</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function f(x) &#123;</span><br><span class="line">  var x;</span><br><span class="line">  var x;</span><br><span class="line">  if (true) &#123;</span><br><span class="line">    var x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="const声明"><a href="#const声明" class="headerlink" title="const声明"></a><code>const</code>声明</h2><p><code>const</code>声明是声明变量的另一种方式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const numLivesForCat = 9;</span><br></pre></td></tr></table></figure>
<p>它们与<code>let</code>声明相似，但是就像它的名字所表达的，它们被赋值后不能再改变。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/01/18/typescript-day02/" data-id="ckymdg9lg0001c0t63bjney0g" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-typescript-day01" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/01/18/typescript-day01/" class="article-date">
  <time datetime="2022-01-18T03:17:55.000Z" itemprop="datePublished">2022-01-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/01/18/typescript-day01/">typescript-day01</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h1><h2 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h2><p>最基本的数据类型就是简单的 true/false </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let isDone: boolean = false;</span><br></pre></td></tr></table></figure>

<h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><p>和javaScript一样，TypeScript 里所有的数字都是浮点数。这些浮点数的类型是 <code>number</code>。 除了支持十进制和十六进制字面量， TypeScript 还支持 ECMAScript 2015中引入的二进制和八进制字面量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let a: number = 6;</span><br><span class="line">let b: number = 0xf00d;</span><br><span class="line">let c: number = 0b1010;</span><br><span class="line">let d: number = 0o744;</span><br></pre></td></tr></table></figure>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>不仅支持双引号(<code>&quot;</code>)或单引号(<code>&#39;</code>)。还可以使用模版字符串</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let name: string = &quot;bob&quot;;</span><br><span class="line">name = &#x27;smith&#x27;</span><br><span class="line"></span><br><span class="line">let name: string = `Gene`;</span><br><span class="line">let age: number = 37;</span><br><span class="line">let sentence: string = `Hello, my name is $&#123; name &#125;.</span><br><span class="line">I&#x27;ll be $&#123;age + 1&#125; years old next month.`;</span><br></pre></td></tr></table></figure>

<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let list: number[] = [1, 2, 3];</span><br><span class="line">let list: Array&lt;number&gt; = [1, 2, 3]</span><br></pre></td></tr></table></figure>

<h2 id="元组-Tuple"><a href="#元组-Tuple" class="headerlink" title="元组 Tuple"></a>元组 Tuple</h2><p>元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let x: [string, number];</span><br><span class="line">x = [&#x27;hello&#x27;, 10]; // ok</span><br><span class="line">x = [1, &#x27;hello&#x27;] // error</span><br><span class="line"></span><br><span class="line">当访问一个已知索引的元素，会得到正确的类型</span><br><span class="line">console.log(x[0].substr(1)); // ok</span><br><span class="line">console.log(x[1].substr(1)); // Error, &#x27;number&#x27; does not have &#x27;substr&#x27; </span><br><span class="line"></span><br><span class="line">当访问一个越界的元素，会使用联合类型替代；</span><br><span class="line">x[3] = &#x27;world&#x27;; // ok  字符串可以赋值给(string | number) 类型</span><br><span class="line">console.log(x[5].toString()); // ok &#x27;string&#x27; 和 &#x27;number&#x27; 都有 toString</span><br><span class="line">x[6] = true // error 布尔不是(string | number) 类型</span><br></pre></td></tr></table></figure>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p><code>enum</code>类型是对JavaScript 标准数据类型的一个补充。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">enum Color &#123;Red, Green, Blue&#125;</span><br><span class="line">let c: Color = Color.Green;</span><br><span class="line"></span><br><span class="line">默认情况下，从0开始为元素编号。</span><br><span class="line"></span><br><span class="line">enum Color &#123;Red = 1, Green, Blue&#125;</span><br><span class="line">let c: Color = Color.Green;</span><br><span class="line"></span><br><span class="line">或者，全部都采用手动赋值：</span><br><span class="line"></span><br><span class="line">enum Color &#123;Red = 1, Green = 2, Blue = 4&#125;</span><br><span class="line">let c: Color = Color.Green;</span><br><span class="line"></span><br><span class="line">枚举类型提供的一个便利是你可以由枚举值得到它的名字。例如，我们知道数值为2，但是不确定它映射到Color里都那个名字，我们可以查找相应的名字；</span><br><span class="line"></span><br><span class="line">enum Color &#123;Red = 1, Green, Bule&#125;</span><br><span class="line">let colorName: string = Color[2];</span><br><span class="line">console.log(colorName); // 显示&#x27;Green&#x27;因为上面代码里的值是2</span><br></pre></td></tr></table></figure>

<h2 id="Any"><a href="#Any" class="headerlink" title="Any"></a>Any</h2><p>有时候，我们会想要那些在编程阶段还不清楚类型的变量指定一个类型。这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查，那么我们可以使用<code>any</code>类型来标记这些变量；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let notSure: any = 4;</span><br><span class="line">notSure = &#x27;maybe a string instead&#x27;;</span><br><span class="line">notSure = false; // ok definitely a boolean</span><br><span class="line"></span><br><span class="line">但是不能够在它上面调用任意的方法，即使它真的有这些方法：</span><br><span class="line"></span><br><span class="line">let notSure: any = 4;</span><br><span class="line">notSure.ifItExists(); // okay, ifItExists might exist at runtime</span><br><span class="line">notSure.toFixed(); // okay, toFixed exists (but the compiler doesn&#x27;t check)</span><br><span class="line"></span><br><span class="line">let prettySure: Object = 4;</span><br><span class="line">prettySure.toFixed(); // Error: Property &#x27;toFixed&#x27; doesn&#x27;t exist on type &#x27;Object&#x27;.</span><br></pre></td></tr></table></figure>
<p>当你只知道一部分数据的类型时，<code>any</code>类型也是有用的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let list: any[] = [1, true, &quot;free&quot;];</span><br><span class="line">list[1] = 100;</span><br></pre></td></tr></table></figure>

<h2 id="Void"><a href="#Void" class="headerlink" title="Void"></a>Void</h2><p>某种程度上说，<code>void</code>类型像是与<code>any</code>类型相反，它表示没有任何类型。当一个函数没有返回值时，你通常会见到其返回值类型是 void;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function warnUser(): void &#123;</span><br><span class="line">  console.log(&quot;This is my warning message&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>声明一个<code>void</code>类型的变量没有什么大用，因为你只能为它赋值<code>undefined</code>和<code>null</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let unusable: void = undefined;</span><br></pre></td></tr></table></figure>

<h2 id="Null-和-Undefined"><a href="#Null-和-Undefined" class="headerlink" title="Null 和 Undefined"></a>Null 和 Undefined</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let u: undefined = undefined;</span><br><span class="line">let n: null = null;</span><br></pre></td></tr></table></figure>
<p>默认情况下<code>null</code>和<code>undefined</code>是所有类型的子类型。<br><code>--strictNullChecks</code>标记，<code>null</code>和<code>undefined</code>只能赋值给<code>void</code>和它们各自。</p>
<h2 id="Never"><a href="#Never" class="headerlink" title="Never"></a>Never</h2><p><code>never</code>类型表示的是那些永不存在的值类型。例如，<code>never</code>类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型；变量也可能是<code>never</code>类型，当它们永不为真的类型保护所约束时。<br><code>never</code>类型是任何类型的子类型,也可以赋值给任何类型；然而，没有类型是<code>never</code>的子类型或可以赋值给<code>never</code>类型.即使<code>any</code>也不可以赋值给<code>never</code>.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 返回的never的函数必须存在无法达到的终点</span><br><span class="line">function error (message: string): never &#123;</span><br><span class="line">  throw new Error(message)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 推断的返回类型是never</span><br><span class="line">function fail()&#123;</span><br><span class="line">  return error(&quot;Something failed);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 返回never的函数必须存在无法达到的终点</span><br><span class="line">function infiniteLoop (): never &#123;</span><br><span class="line">  while(true)&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><p><code>object</code>表示非与那时类型，也就是除了number, string, boolean, symobl, nbull 或<code>undefined外的类型。 使用</code>object<code>类型，就可以更好的表示像</code>Object.create`这样的API</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">declare function create(o: object | null): void;</span><br><span class="line"></span><br><span class="line">create(&#123; prop: 0 &#125;); //ok</span><br><span class="line">create(null); //ok</span><br><span class="line"></span><br><span class="line">create(42); //Error</span><br><span class="line">create(&quot;string&quot;); // Error</span><br><span class="line">create(false); // Error</span><br><span class="line">create(undefined); // Error</span><br></pre></td></tr></table></figure>
<h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><p>类型断言有两种形式.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let someValue: any = &quot;this is a string&quot;</span><br><span class="line"></span><br><span class="line">let strLength: number = (&lt;string&gt;someValue).length;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>另一个为<code>as</code>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let someValue: any = &quot;this is a string&quot;</span><br><span class="line">let strLength: number = (someValue as string).length;</span><br></pre></td></tr></table></figure>
<h2 id="关于let"><a href="#关于let" class="headerlink" title="关于let"></a>关于<code>let</code></h2><p>使用 <code>let</code>来代替<code>var</code></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/01/18/typescript-day01/" data-id="ckymdg9lc0000c0t62hlb3uvn" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-flex" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/01/17/flex/" class="article-date">
  <time datetime="2022-01-17T02:28:43.000Z" itemprop="datePublished">2022-01-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/01/17/flex/">Flex 布局是什么？</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Flexible Box 模型， 通常被称为 flexbox ，是一种一维的布局模型。它给 flexbox 的子元素之间提供了强大的空间分布和对齐能力。</p>
<p>我们说 flexbox 是一种一维的布局，是因为一个 flexbox 一次只能处理一个维度上的元素布局，一行或者一列。作为对比的是另一个二维布局 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Grid_Layout">CSS Grid Layout</a>， 可以同时处理行和列上的布局</p>
<h2 id="flexbox-的两个轴线"><a href="#flexbox-的两个轴线" class="headerlink" title="flexbox 的两个轴线"></a>flexbox 的两个轴线</h2><p>当使用 flex 布局时，首先想到的是两根轴线- 主轴和交叉轴。 主轴由 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-direction">flex-direction</a> 定义,另一根轴线垂直于它。我们使用 flexbox 的所有属性都跟这两根轴线有关，所以有必要一开始首先就理解它。</p>
<h3 id="主轴"><a href="#主轴" class="headerlink" title="主轴"></a>主轴</h3><p>主轴由<code>flex-direction</code> 定义, 可以取4个值:</p>
<ul>
<li><code>row</code></li>
<li><code>row-reverse</code></li>
<li><code>column</code></li>
<li><code>column-reverse</code></li>
</ul>
<p>如果你选择了 <code>row</code>或者<code>row-reverse</code>,你的主轴将沿着inline方向延伸。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;-    Main Axis - flex-direction: row  -&gt;</span><br><span class="line">a   b   c</span><br></pre></td></tr></table></figure>
<p>选择<code>column</code> 或者 <code>column-reverse</code> 时，你的主轴会沿着上下方向延伸 – 也就是block 排列的方向。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|      a</span><br><span class="line">|      b</span><br><span class="line">|      c</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="交叉轴"><a href="#交叉轴" class="headerlink" title="交叉轴"></a>交叉轴</h3><p><strong>交叉轴是垂直于主轴的.</strong></p>
<h2 id="起始线和终止线"><a href="#起始线和终止线" class="headerlink" title="起始线和终止线"></a>起始线和终止线</h2><p>另外一个需要理解的重点是 flexbox 不会对文档的书写模式提供假设。过去，css 的书写模式主要被认为是水平的，从左到右的。现代的布局方式涵盖了书写模式的范围，所以我们不再假设一行文字是从文档的左上角开始向右书写，新的行业不是必须出现在另一行的下面。</p>
<h2 id="flex-容器"><a href="#flex-容器" class="headerlink" title="flex 容器"></a>flex 容器</h2><p>文档中采用了 flexbox 的区域就叫做 flex 容器。为了创建 felx容器，我们把一个容器 display 属性值改成 flex 或者 inline-flex。完成这一步后，容器中直系子元素就会变为 flex 元素。所有css属性都会有一个初始值 ，所以 flex容器中的所有flex元素都会有下列行为：</p>
<ul>
<li>元素排列为一行(<code>flex-direction</code>属性的初始值是<code>row</code>)</li>
<li>元素从主轴的起始线开始。</li>
<li>元素不会在主维度方向拉伸，但是可以缩小。</li>
<li>元素被拉伸填充交叉轴大小</li>
<li><code>flex-basis</code>属性为 auto.</li>
<li><code>flex-wrap</code>属性为 nowrap.</li>
</ul>
<p>这会让你的元素呈线性排列，并且把自己的大小作为主轴上的大小。如果有太多元素超出容器，它们会溢出而不会换行。如果一些元素比其他元素高，那么元素沿交叉轴被拉伸来填满它的大小。</p>
<p><a target="_blank" rel="noopener" href="https://codepen.io/zengzhiwei/pen/eYGXvzE">https://codepen.io/zengzhiwei/pen/eYGXvzE</a></p>
<h3 id="更改flex方向-flex-direction"><a href="#更改flex方向-flex-direction" class="headerlink" title="更改flex方向 flex-direction"></a>更改flex方向 flex-direction</h3><p>在 flex 容器中添加 flex-direction 属性可以让我们更改flex 元素的排列方向。设置 <code>flex-direction: row-reverse</code> 可以让元素沿着行的方向显示,但是起始线和终止线会交换.</p>
<p>把flex 容器的属性<code>flex-direction</code>改为<code>column</code>,主轴和交叉轴交换,元素沿着列的方向排列显示。改为<code>column-reverse</code>，起始线和终止线交换。</p>
<p><a target="_blank" rel="noopener" href="https://codepen.io/zengzhiwei/pen/gOGEmWO">https://codepen.io/zengzhiwei/pen/gOGEmWO</a></p>
<h3 id="用-flex-wrap-实现多行flex容器"><a href="#用-flex-wrap-实现多行flex容器" class="headerlink" title="用 flex-wrap  实现多行flex容器"></a>用 flex-wrap  实现多行flex容器</h3><p>虽然<code>flexbox</code>是一维模型，但可以使我们的<code>flex</code>项目应用到多行中。在这样做的时候，您应该把每一行看作一个新的<code>flex</code>容器。任何空间分布都将在该行上发生，而不影响该空间分布的其他行。<br>为了实现多行的效果，请为属性<code>flex-wrap</code>添加一个属性值<code>wrap</code>。</p>
<p><a target="_blank" rel="noopener" href="https://codepen.io/zengzhiwei/pen/qBPvjEq">https://codepen.io/zengzhiwei/pen/qBPvjEq</a></p>
<h3 id="简写属性-flex-flow"><a href="#简写属性-flex-flow" class="headerlink" title="简写属性 flex-flow"></a>简写属性 flex-flow</h3><p>可以将 <code>flex-direction</code>和<code>flex-wrap</code>组合成一个属性<code>flex-flow</code>。第一个指定的值是<code>flex-direction</code>,第二个指定的值为<code>flex-wrap</code></p>
<p><a target="_blank" rel="noopener" href="https://codepen.io/zengzhiwei/pen/poWYwjX">https://codepen.io/zengzhiwei/pen/poWYwjX</a></p>
<h2 id="flex元素上的属性"><a href="#flex元素上的属性" class="headerlink" title="flex元素上的属性"></a>flex元素上的属性</h2><p>为了更好的控制flex元素</p>
<ul>
<li><code>flex-grow</code></li>
<li><code>flex-shrink</code></li>
<li><code>flex-basis</code></li>
</ul>
<p>在考虑这几个属性的作用之前，需要先了解下<strong>可用空间</strong><code>available space</code> 这个概念。这几个flex属性的作用其实就是改变了flex容器中的可用空间的行为。同时，可用空间对于flex元素的对齐行为也是很重要的。</p>
<p>假设再1个500px 的容器中，我们有3个100px 宽的元素，那么这3个元素需要占300px 的宽，剩下 200px 的可用空间。在默认情况下，flexbox的行为会把这200px 的空间留在最后一个元素的后面。</p>
<p><a target="_blank" rel="noopener" href="https://codepen.io/zengzhiwei/pen/abLMwmm">https://codepen.io/zengzhiwei/pen/abLMwmm</a></p>
<p>如果期望这些元素能自动地扩展去填充满剩下的空间，那么我们需要去控制可用空间在这几个元素间如何分配，这就是元素上的那么<code>flex</code>属性要做的事情。</p>
<h3 id="flex-元素属性-flex-basis"><a href="#flex-元素属性-flex-basis" class="headerlink" title="flex 元素属性: flex-basis"></a>flex 元素属性: <code>flex-basis</code></h3><p><code>flex-basis</code> 定义了该元素的<strong>空间大小</strong><code>(the size of that item in terms of the space</code>),flex容器里除了元素所占的空间之外的富余空间就是<strong>可用空间</strong>(<code>available space</code>).该属性的默认值是<code>auto</code>。此时，游览器会检测这个元素是否具有确定的尺寸。在上面的例子中，所有元素都设定了宽度 100px，所以<code>flex-basis</code>的值为100px.</p>
<p>如果没有给元素设定尺寸，<code>flex-basis</code>的值采用元素内容的尺寸。这就解释了：我们只要给Flex元素的父元素声明<code>display: flex;</code>，所有子元素就会排成一行，且自动分配大小以充分展示元素的内容。</p>
<h3 id="flex元素属性-flex-grow"><a href="#flex元素属性-flex-grow" class="headerlink" title="flex元素属性:flex-grow"></a>flex元素属性:<code>flex-grow</code></h3><p><code>flex-grow</code>若被赋值为一个正整数，flex元素会议<code>flex-basis</code>为基础，沿着主轴方向增长尺寸。这会使该元素延展，并占据此方向轴上的可用空间(<code>available space</code>).如果有其他元素也被允许延展，那么他们会各自占据可用空间的一部分。</p>
<p>如果我们给上例中的所有元素设定<code>flex-grow</code>值为1，容器中的可用空间会被这些元素评分。它们会延展以填满容器主轴方向上的空间。<br><code>flex-grow</code>属性可以按比例分配空间。如果第一个元素<code>flex-grow</code>值为2,其他元素值为1,则第一个元素将占有2/4.</p>
<h3 id="flex元素属性：flex-shrink"><a href="#flex元素属性：flex-shrink" class="headerlink" title="flex元素属性：flex-shrink"></a>flex元素属性：<code>flex-shrink</code></h3><p><code>flex-grow</code>属性是处理flex元素在主轴上增加空间的问题，相反<code>flex-shrink</code>属性是处理flex元素收缩的问题。如果我们容器中没有足够排列flex元素的空间，那么可以把flex元素<code>flex-shrink</code>属性设置为正整数来缩小它所占空间到<code>flex-basis</code>以下。与<code>flex-grow</code>属性一样，可以赋予不同的值来控制flex元素收缩的程度—给<code>flex-shrink</code>属性赋予更大的数值可以比赋予小数值的同级元素收缩程度更大。</p>
<p><a target="_blank" rel="noopener" href="https://codepen.io/zengzhiwei/pen/yLzwXpN">https://codepen.io/zengzhiwei/pen/yLzwXpN</a></p>
<h2 id="元素间的对齐和空间分配"><a href="#元素间的对齐和空间分配" class="headerlink" title="元素间的对齐和空间分配"></a>元素间的对齐和空间分配</h2><p>Flexbox的一个关键特性是能够设置flex元素沿着主轴方向和交叉轴方向的对齐方式，以及它们之间的空间分配。</p>
<h3 id="align-item"><a href="#align-item" class="headerlink" title="align-item"></a><code>align-item</code></h3><p><code>align-item</code>属性可以使元素在交叉轴方向对齐<br>这个属性的初始值为<code>stretch</code>，这就是为什么flex元素会默认被拉伸到最高元素的高度。实际上，它们被拉伸来填满flex容器 —- 最高的元素定义了容器的高度。</p>
<p>你也可以设置<code>align-items</code>的值为<code>flex-start</code>,使flex元素按flex容器的顶部对齐，<code>flex-end</code>使它们按flex容器的下部对齐，或者<code>center</code>使它们居中对齐</p>
<p><a target="_blank" rel="noopener" href="https://codepen.io/zengzhiwei/pen/OJxqgoq">https://codepen.io/zengzhiwei/pen/OJxqgoq</a></p>
<h3 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a><code>justify-content</code></h3><p><code>justify-content</code>属性用来使元素在主轴方向上对齐,主轴方向是通过<code>flex-direction</code>设置的方向。初始值是<code>flex-start</code>，元素从容器的起始线排列。但是你也可以把值设置为<code>flex-end</code>，从终止线开始排列，或者<code>center</code>，在中间排列。</p>
<p>你也可以把值设置为<code>space-between</code>,把元素排列好之后的剩余空间拿处理啊，平均分配到元素之间,所以元素之间间隔相等。或者使用<code>space-around</code>，使每个元素的左右空间相等。</p>
<p><a target="_blank" rel="noopener" href="https://codepen.io/zengzhiwei/pen/OJxqgoq">https://codepen.io/zengzhiwei/pen/OJxqgoq</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/01/17/flex/" data-id="ckyiecs9l0000r8t6bbb30gt9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-event-loop" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/01/14/event-loop/" class="article-date">
  <time datetime="2022-01-14T08:23:37.000Z" itemprop="datePublished">2022-01-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/01/14/event-loop/">深入：微任务与JavaScript 运行时环境</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="JavaScript-执行上下文"><a href="#JavaScript-执行上下文" class="headerlink" title="JavaScript 执行上下文"></a>JavaScript 执行上下文</h1><p>当一段 JavaScipt 代码在运行的时候，它实际上运行在执行上下文中。下面3种类型会创建一个新的执行上下文：</p>
<ul>
<li>全局上线爱问是为运行代码主体而创建的执行上下文，也就是说它是为那些存在于JavaScript 函数之外的任何代码而创建的。</li>
<li>每个函数会在执行的时候创建自己的执行上下文。这个上下文就是通常说的“本地上下文”。</li>
<li>使用 eval() 函数也会创建一个新的执行上下文。</li>
</ul>
<p>每一个上下文的本质上都是一种作用域层级。每个代码段开始执行的时候都会创建一个新的上下文来运行它，并且在代码退出的时候销毁掉。</p>
<h1 id="游览器中的事件循环"><a href="#游览器中的事件循环" class="headerlink" title="游览器中的事件循环"></a>游览器中的事件循环</h1><p>每个代理都是由事件循环驱动的，事件循环负责收集用事件（包含用户事件以及其他非用户事件等）、对任务进行排队以便在合适的时候执行回调。然后它执行所有处于等待中的 JavaScript 任务（宏任务） ，然后是 微任务，然后在开始下一次循环之前执行一些必要的渲染和绘制操作。</p>
<p>网页或者app 的代码和游览器本身的用户界面程序运行在相同的线程中，共享相同的事件循环。该线程就是主线程，它除了运行网页本身的代码之外，还负责收集和派发用户和其他事件，以及渲染和绘制网页内容等。</p>
<p>然后，事件循环会驱动发生在游览器中与用户交互有关的一切，但在这里，对我们来说更重要的是需要了解它是如何负责调度和执行在其线程中执行的每段代码的。</p>
<h3 id="Window-事件循环"><a href="#Window-事件循环" class="headerlink" title="Window 事件循环"></a><strong>Window 事件循环</strong></h3><p>  window 事件循环驱动所有同源的窗口</p>
<h3 id="Worker-事件循环"><a href="#Worker-事件循环" class="headerlink" title="Worker 事件循环"></a><strong>Worker 事件循环</strong></h3><p>  worker事件循环顾名思义就是驱动 worker 的事件循环。这包括了所有种类的 worker；最基本的 web worker 以及 shared worker 和 service worker。 Worler 被放在一个或多个独立于“主代码”的代理中。游览器可能会用单个或多个事件循环来处理给定类型的所有 worker。</p>
<h3 id="Worklet-事件循环"><a href="#Worklet-事件循环" class="headerlink" title="Worklet 事件循环"></a><strong>Worklet 事件循环</strong></h3><p>  worklet 事件循环用于驱动运行 worklet 的代理。这包含了 Worklet 、 AudioWorklet 以及 PaintWorklet</p>
<h2 id="（宏任务）-任务-VS-微任务"><a href="#（宏任务）-任务-VS-微任务" class="headerlink" title="（宏任务） 任务 VS 微任务"></a>（宏任务） 任务 VS 微任务</h2><p>一个（宏任务）任务就是指计划由标准机制来执行的任何 javascript， 如程序的初始化、事件触发的回调等。<br>例如： setTimeout 或者 setInterval() 来添加任务</p>
<p>任务队列和微任务队列的区分很简单，但却很重要：</p>
<ul>
<li>当执行来自任务队列中的任务时，在每一次新的事件循环开始迭代的时候运行时都会执行队列中的每个任务。在每次迭代开始之后加入到队列中的任务需要在下一次迭代开始之后才会被执行。</li>
<li>每次当一个任务退出且执行上下文为空的时候，微任务队列中的每一个微任务会依次被执行。不同的是它会等到微任务队列为空才会停止执行—即使中途有微任务加入。换句话说，微任务可以添加新的微任务到队列中，并在下一个任务开始执行之前且当前事件循环结束之前执行完所有的微任务。</li>
</ul>
<p>macro-task 大概包括：</p>
<ul>
<li>script （整体代码）</li>
<li>setTimeout</li>
<li>setInterval</li>
<li>setImmediate</li>
<li>I/O</li>
<li>UI rendermicro-task 大概包括：<ul>
<li>process.nextTick</li>
<li>Promise</li>
<li>Async/Await （实际就是 promise）</li>
<li>MutationObserver （html5 新特性）</li>
</ul>
</li>
</ul>
<p>整体执行</p>
<p>&lt;%- image_tag(‘./../../public/css/images/el1.png’, [options]) %&gt;</p>
<p>总的结论就是,</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/01/14/event-loop/" data-id="ckye5egju0000ekt67gyg0gvw" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/01/14/hello-world/" class="article-date">
  <time datetime="2022-01-14T07:40:12.636Z" itemprop="datePublished">2022-01-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/01/14/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/01/14/hello-world/" data-id="ckye4d3wl0000qwt68xks5o4m" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">一月 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/01/18/typescript-day03/">typescript-day03</a>
          </li>
        
          <li>
            <a href="/2022/01/18/typescript-day02/">typescript-day02</a>
          </li>
        
          <li>
            <a href="/2022/01/18/typescript-day01/">typescript-day01</a>
          </li>
        
          <li>
            <a href="/2022/01/17/flex/">Flex 布局是什么？</a>
          </li>
        
          <li>
            <a href="/2022/01/14/event-loop/">深入：微任务与JavaScript 运行时环境</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 zzw<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>