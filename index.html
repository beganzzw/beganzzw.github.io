<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>began个人博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="学习笔记">
<meta property="og:type" content="website">
<meta property="og:title" content="began个人博客">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="began个人博客">
<meta property="og:description" content="学习笔记">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="zzw">
<meta property="article:tag" content="笔记">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="began个人博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">began个人博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-nodejs-study-day1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/03/15/nodejs-study-day1/" class="article-date">
  <time datetime="2022-03-15T02:08:48.000Z" itemprop="datePublished">2022-03-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/03/15/nodejs-study-day1/">nodejs_study_day1</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h1><h2 id="初始创建Hello-World"><a href="#初始创建Hello-World" class="headerlink" title="初始创建Hello World"></a>初始创建Hello World</h2><p>以下<code>req</code>为<code>request</code>。<code>res</code>为<code>response</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 引入htpp模块</span><br><span class="line">var http = require(&quot;http&quot;)</span><br><span class="line">// 创建服务器 并监听3000端口</span><br><span class="line">http.createServer(function (req, res)&#123;</span><br><span class="line">  res.writeHead(200,&#123;&quot;Content-Type&quot;: &quot;text/plain&quot;&#125;);</span><br><span class="line">  res.write(&#x27;Hello World&#x27;);</span><br><span class="line">  res.end();</span><br><span class="line">&#125;).listen(3000)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>通过node 文件名 启动</strong>随即打开<code>localhost:3000/</code><br>页面显示<code>Hello World</code></p>
<h2 id="简单模块化"><a href="#简单模块化" class="headerlink" title="简单模块化"></a>简单模块化</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var http = require(&quot;http&quot;)</span><br><span class="line"></span><br><span class="line">function start () &#123;</span><br><span class="line">  function onRequest(req, res) &#123;</span><br><span class="line">    console.log(&quot;Request received&quot;)</span><br><span class="line">    res.writeHead(200,&#123;&quot;Content-Type&quot;: &quot;text/plain&quot;&#125;) </span><br><span class="line">    res.write(&quot;Hello World&quot;)</span><br><span class="line">    res.end()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  http.createServer(onRequest).listen(3000)</span><br><span class="line">  console.log(&quot;Server has started&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">exports.start = start</span><br></pre></td></tr></table></figure>
<p>可以将编写的<code>server.js</code> 文件通过<code>start</code>函数进行封装。在其他模块下<br>例如: <code>index.js</code>模块中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var server = require(&#x27;./server&#x27;)</span><br><span class="line"></span><br><span class="line">server.start()</span><br></pre></td></tr></table></figure>
<p>通过这种方式进行使用</p>
<h2 id="简单路由"><a href="#简单路由" class="headerlink" title="简单路由"></a>简单路由</h2><p>对路由进行处理需要用到node自带模块<code>url</code>和<code>querystring</code></p>
<p><code>http://localhost:3000/start?foo=bar&amp;hello=world</code></p>
<p><code>url.parse(string).pathname</code>     -&gt; start</p>
<p><code>url.parse(string).query</code>        -&gt; foo=bar&amp;hello=world</p>
<p><code>querystring(string)[&quot;foo&quot;]</code>     -&gt; bar</p>
<p><code>querystring(string)[&quot;hello&quot;]</code>   -&gt; world</p>
<p>对<code>server.js</code>进行改造</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var http = require(&quot;http&quot;)</span><br><span class="line">var url = require(&quot;url&quot;)</span><br><span class="line"></span><br><span class="line">function start (route) &#123;</span><br><span class="line">  function onRequest(req, res) &#123;</span><br><span class="line">    var pathname = url.parse(req.url).pathname</span><br><span class="line">    </span><br><span class="line">    console.log(&quot;Request for &quot; + pathname + &quot;received&quot;)</span><br><span class="line"></span><br><span class="line">    route(pathname)</span><br><span class="line">    res.writeHead(200,&#123;&quot;Content-Type&quot;: &quot;text/plain&quot;&#125;) </span><br><span class="line">    res.write(&quot;Hello World&quot;)</span><br><span class="line">    res.end()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  http.createServer(onRequest).listen(3000)</span><br><span class="line">  console.log(&quot;Server has started&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">exports.start = start</span><br></pre></td></tr></table></figure>
<p>新建<code>route.js</code>文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function route(pathname)&#123;</span><br><span class="line">  console.log(&quot;About to route a request for &quot; + pathname)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.route = route</span><br></pre></td></tr></table></figure>
<p>在<code>index.js</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var server = require(&#x27;./server&#x27;)</span><br><span class="line">var route = require(&#x27;./router&#x27;)</span><br><span class="line">server.start(route.route)</span><br></pre></td></tr></table></figure>
<p>服务器端打印结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Request for /foo received</span><br><span class="line">About to route a request for /foo</span><br></pre></td></tr></table></figure>
<p>去除了<code>favicon</code>的打印信息</p>
<h2 id="路由的请求处理程序"><a href="#路由的请求处理程序" class="headerlink" title="路由的请求处理程序"></a>路由的请求处理程序</h2><p>新建<code>requestHandlers.js</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function start()&#123;</span><br><span class="line">  console.log(&quot;Request handler &#x27;start&#x27; was called &quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function upload()&#123;</span><br><span class="line">  console.log(&quot;Request handler &#x27;upload&#x27; was called &quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.start = start;</span><br><span class="line"></span><br><span class="line">exports.upload = upload;</span><br></pre></td></tr></table></figure>
<p>对<code>index.js</code>进行改造</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var server = require(&#x27;./server&#x27;)</span><br><span class="line">var route = require(&#x27;./router&#x27;)</span><br><span class="line">var requestHandlers = require(&#x27;./requestHandlers&#x27;)</span><br><span class="line"></span><br><span class="line">var handle = &#123;&#125;</span><br><span class="line">handle[&quot;/&quot;] = requestHandlers.start</span><br><span class="line">handle[&quot;/start&quot;] = requestHandlers.start</span><br><span class="line">handle[&quot;/upload&quot;] = requestHandlers.upload</span><br><span class="line"></span><br><span class="line">server.start(route.route,handle)</span><br></pre></td></tr></table></figure>
<p>对<code>server.js</code>进行改造</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var http = require(&quot;http&quot;)</span><br><span class="line">var url = require(&quot;url&quot;)</span><br><span class="line"></span><br><span class="line">function start (route, handle) &#123;</span><br><span class="line">  function onRequest(req, res) &#123;</span><br><span class="line">    var pathname = url.parse(req.url).pathname</span><br><span class="line"></span><br><span class="line">    console.log(&quot;Request for &quot; + pathname + &quot; received&quot;)</span><br><span class="line"></span><br><span class="line">    route(handle, pathname)</span><br><span class="line">    res.writeHead(200,&#123;&quot;Content-Type&quot;: &quot;text/plain&quot;&#125;) </span><br><span class="line">    res.write(&quot;Hello World&quot;)</span><br><span class="line">    res.end()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  http.createServer(onRequest).listen(3000)</span><br><span class="line">  console.log(&quot;Server has started&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">exports.start = start</span><br></pre></td></tr></table></figure>
<p>对<code>route.js</code>改造</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function route(handle,pathname)&#123;</span><br><span class="line">  console.log(&quot;About to route a request for &quot; + pathname)</span><br><span class="line">  if (typeof handle[pathname] === &#x27;function&#x27;)&#123;</span><br><span class="line">    handle[pathname]();</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    console.log(&quot;No request handler found for &quot; + pathname)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.route = route</span><br></pre></td></tr></table></figure>
<p><strong>运行结果</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Request for /start received</span><br><span class="line">About to route a request for /start</span><br><span class="line">Request handler &#x27;start&#x27; was called</span><br></pre></td></tr></table></figure>
<h2 id="请求处理程序作出响应"><a href="#请求处理程序作出响应" class="headerlink" title="请求处理程序作出响应"></a>请求处理程序作出响应</h2><p><code>requsetHandler.js</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function start()&#123;</span><br><span class="line">  console.log(&quot;Request handler &#x27;start&#x27; was called &quot;)</span><br><span class="line">  return &quot;Hello Start&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function upload()&#123;</span><br><span class="line">  console.log(&quot;Request handler &#x27;upload&#x27; was called &quot;)</span><br><span class="line">  return &quot;Hello Upload&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.start = start;</span><br><span class="line"></span><br><span class="line">exports.upload = upload;</span><br></pre></td></tr></table></figure>
<p><code>route.js</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function route(handle,pathname)&#123;</span><br><span class="line">  console.log(&quot;About to route a request for &quot; + pathname)</span><br><span class="line">  if (typeof handle[pathname] === &#x27;function&#x27;)&#123;</span><br><span class="line">    return handle[pathname]();</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    console.log(&quot;No request handler found for &quot; + pathname)</span><br><span class="line">    return &quot;404 Not found&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.route = route</span><br></pre></td></tr></table></figure>
<p><code>server.js</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var http = require(&quot;http&quot;)</span><br><span class="line">var url = require(&quot;url&quot;)</span><br><span class="line"></span><br><span class="line">function start (route, handle) &#123;</span><br><span class="line">  function onRequest(req, res) &#123;</span><br><span class="line">    var pathname = url.parse(req.url).pathname</span><br><span class="line"></span><br><span class="line">    console.log(&quot;Request for &quot; + pathname + &quot; received&quot;)</span><br><span class="line"></span><br><span class="line">    res.writeHead(200,&#123;&quot;Content-Type&quot;: &quot;text/plain&quot;&#125;) </span><br><span class="line">    var content = route(handle, pathname)</span><br><span class="line">    res.write(content)</span><br><span class="line">    res.end()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  http.createServer(onRequest).listen(3000)</span><br><span class="line">  console.log(&quot;Server has started&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">exports.start = start</span><br></pre></td></tr></table></figure>
<p>运行<code>localhost:3000/start</code>页面显示 <code>Hello Start</code></p>
<p>运行<code>localhost:3000/upload</code>页面显示<code>Hello Upload</code></p>
<p>运行<code>localhost:3000/foo</code>   页面显示 <code>404 Not found</code></p>
<h2 id="阻塞行为"><a href="#阻塞行为" class="headerlink" title="阻塞行为"></a>阻塞行为</h2><p>修改<code>requestHandlers.js</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function start()&#123;</span><br><span class="line">  console.log(&quot;Request handler &#x27;start&#x27; was called &quot;)</span><br><span class="line">  function sleep(milliSeconds) &#123;</span><br><span class="line">    var startTime = new Date().getTime();</span><br><span class="line">    while(new Date().getTime() &lt; startTime + milliSeconds);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sleep(10000);</span><br><span class="line">  return &quot;Hello Start&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function upload()&#123;</span><br><span class="line">  console.log(&quot;Request handler &#x27;upload&#x27; was called &quot;)</span><br><span class="line">  return &quot;Hello Upload&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.start = start;</span><br><span class="line"></span><br><span class="line">exports.upload = upload;</span><br></pre></td></tr></table></figure>
<p>分别运行<code>/start</code>与<code>/upload</code>会发现两个页面差不多都运行了10s时间才返回结果。<br>可以使用<strong>事件轮询</strong>来避免.</p>
<h3 id="非阻塞操作例子"><a href="#非阻塞操作例子" class="headerlink" title="非阻塞操作例子"></a>非阻塞操作例子</h3><p>修改<code>requestHandlers.js</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var exec = require(&quot;child_process&quot;).exec</span><br><span class="line">function start()&#123;</span><br><span class="line">  console.log(&quot;Request handler &#x27;start&#x27; was called &quot;)</span><br><span class="line">  var content = &quot;empty&quot;</span><br><span class="line">  </span><br><span class="line">  exec(&quot;ls -lah&quot;, function(error, stdout, stderr) &#123;</span><br><span class="line">    content = stdout;</span><br><span class="line">  &#125;)</span><br><span class="line">  return content</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function upload()&#123;</span><br><span class="line">  console.log(&quot;Request handler &#x27;upload&#x27; was called &quot;)</span><br><span class="line">  return &quot;Hello Upload&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.start = start;</span><br><span class="line"></span><br><span class="line">exports.upload = upload;</span><br></pre></td></tr></table></figure>

<h3 id="简单上传文件例子"><a href="#简单上传文件例子" class="headerlink" title="简单上传文件例子"></a>简单上传文件例子</h3><p>修改<code>serve.js</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var http = require(&quot;http&quot;)</span><br><span class="line">var url = require(&quot;url&quot;)</span><br><span class="line"></span><br><span class="line">function start (route, handle) &#123;</span><br><span class="line">  function onRequest(request, response) &#123;</span><br><span class="line">    var postData = &quot;&quot;;</span><br><span class="line">    var pathname = url.parse(request.url).pathname</span><br><span class="line"></span><br><span class="line">    console.log(&quot;Request for &quot; + pathname + &quot; received&quot;)</span><br><span class="line"></span><br><span class="line">    route(handle,pathname, response,request)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  http.createServer(onRequest).listen(3000)</span><br><span class="line">  console.log(&quot;Server has started&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">exports.start = start</span><br></pre></td></tr></table></figure>
<p>修改<code>requestHandlers.js</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">var querystring = require(&quot;querystring&quot;),</span><br><span class="line">    fs = require(&quot;fs&quot;),</span><br><span class="line">    formidable = require(&quot;formidable&quot;)</span><br><span class="line"></span><br><span class="line">function start(response)&#123;</span><br><span class="line">  console.log(&quot;Request handler &#x27;start&#x27; was called.&quot;);</span><br><span class="line"></span><br><span class="line">  var body =&#x27;&lt;html&gt;&#x27;+</span><br><span class="line">    &#x27;&lt;head&gt;&#x27;+</span><br><span class="line">    &#x27;&lt;meta http-equiv=&quot;Content-Type&quot; &#x27;+</span><br><span class="line">    &#x27;content=&quot;text/html; charset=UTF-8&quot; /&gt;&#x27;+</span><br><span class="line">    &#x27;&lt;/head&gt;&#x27;+</span><br><span class="line">    &#x27;&lt;body&gt;&#x27;+</span><br><span class="line">    &#x27;&lt;form action=&quot;/upload&quot; enctype=&quot;multipart/form-data&quot;  &#x27;+</span><br><span class="line">    &#x27;method=&quot;post&quot;&gt;&#x27;+</span><br><span class="line">    &#x27;&lt;input type=&quot;file&quot; name=&quot;upload&quot;&gt;&#x27;+</span><br><span class="line">    &#x27;&lt;input type=&quot;submit&quot; value=&quot;Upload file&quot; /&gt;&#x27;+</span><br><span class="line">    &#x27;&lt;/form&gt;&#x27;+</span><br><span class="line">    &#x27;&lt;/body&gt;&#x27;+</span><br><span class="line">    &#x27;&lt;/html&gt;&#x27;;</span><br><span class="line"></span><br><span class="line">    response.writeHead(200,&#123;&quot;Content-Type&quot;:&quot;text/html&quot;&#125;);</span><br><span class="line">    response.write(body);</span><br><span class="line">    response.end();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function upload(response, request)&#123;</span><br><span class="line">  console.log(&quot;Request handler &#x27;upload&#x27; was called.&quot;);</span><br><span class="line"></span><br><span class="line">  var form =new formidable.IncomingForm();</span><br><span class="line">  form.uploadDir =&quot;./tmp&quot;</span><br><span class="line">  form.keepExtensions = true</span><br><span class="line">  console.log(&quot;about to parse&quot;);</span><br><span class="line">  form.parse(request,function(error, fields, files)&#123;</span><br><span class="line">    console.log(&quot;parsing done&quot;);</span><br><span class="line">    console.log(files.upload,&quot;files&quot;);</span><br><span class="line">    fs.renameSync(files.upload.filepath,&quot;./tmp/test.png&quot;);</span><br><span class="line">    response.writeHead(200,&#123;&quot;Content-Type&quot;:&quot;text/html&quot;&#125;);</span><br><span class="line">    response.write(&quot;received image:&lt;br/&gt;&quot;);</span><br><span class="line">    response.write(&quot;&lt;img src=&#x27;/show&#x27; /&gt;&quot;);</span><br><span class="line">    response.end();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function show(response)&#123;</span><br><span class="line">  console.log(&quot;Request handler &#x27;show&#x27; was called.&quot;);</span><br><span class="line">  fs.readFile(&quot;./tmp/test.png&quot;,&quot;binary&quot;,function(error, file)&#123;</span><br><span class="line">    if(error)&#123;</span><br><span class="line">      response.writeHead(500,&#123;&quot;Content-Type&quot;:&quot;text/plain&quot;&#125;);</span><br><span class="line">      response.write(error +&quot;\n&quot;);</span><br><span class="line">      response.end();</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      response.writeHead(200,&#123;&quot;Content-Type&quot;:&quot;image/png&quot;&#125;);</span><br><span class="line">      response.write(file,&quot;binary&quot;);</span><br><span class="line">      response.end();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.start = start;</span><br><span class="line">exports.upload = upload;</span><br><span class="line">exports.show = show;</span><br></pre></td></tr></table></figure>
<p>修改<code>index.js</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var server = require(&#x27;./server&#x27;)</span><br><span class="line">var route = require(&#x27;./router&#x27;)</span><br><span class="line">var requestHandlers = require(&#x27;./requestHandlers&#x27;)</span><br><span class="line"></span><br><span class="line">var handle = &#123;&#125;</span><br><span class="line">handle[&quot;/&quot;] = requestHandlers.start</span><br><span class="line">handle[&quot;/start&quot;] = requestHandlers.start</span><br><span class="line">handle[&quot;/upload&quot;] = requestHandlers.upload</span><br><span class="line">handle[&quot;/show&quot;] = requestHandlers.show</span><br><span class="line"></span><br><span class="line">server.start(route.route,handle)</span><br></pre></td></tr></table></figure>
<p>修改<code>route.js</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function route(handle,pathname,response,request)&#123;</span><br><span class="line">  console.log(&quot;About to route a request for &quot; + pathname)</span><br><span class="line">  if (typeof handle[pathname] === &#x27;function&#x27;)&#123;</span><br><span class="line">    return handle[pathname](response, request);</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    console.log(&quot;No request handler found for &quot; + pathname)</span><br><span class="line">    response.writeHead(404,&#123;&quot;Content-Type&quot;:&quot;text/plain&quot;&#125;);</span><br><span class="line">    response.write(&#x27;404 Not Found&#x27;)</span><br><span class="line">    response.end();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.route = route</span><br></pre></td></tr></table></figure>
<p><code>Window</code>用户需在项目路径下创建<code>tmp</code>目录</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/15/nodejs-study-day1/" data-id="cljfboj3800058cb69c25cmle" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/node/" rel="tag">node</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-interview-01" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/02/17/interview-01/" class="article-date">
  <time datetime="2022-02-17T02:19:28.000Z" itemprop="datePublished">2022-02-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/02/17/interview-01/">interview_01</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="页面导入样式时，使用link和-import有什么区别？"><a href="#页面导入样式时，使用link和-import有什么区别？" class="headerlink" title="页面导入样式时，使用link和@import有什么区别？"></a>页面导入样式时，使用link和@import有什么区别？</h1><ul>
<li><code>link</code>是<code>html</code>提供的标签，不仅仅可以加载样式，还可以定义其他属性。<code>@import</code>是<code>css</code>提供的语法，只可以添加样式。</li>
<li><code>link</code>是在页面加载中时同时加载的。<code>@import</code>加载的<code>css</code>要等页面加载完毕后才加载</li>
<li><code>link</code>没有兼容性问题，<code>@import</code>不兼容<code>ie5</code>以下。</li>
<li><code>link</code>可以通过<code>js</code>操作<code>DOM</code>动态引入样式来改变样式,<code>@import</code>不可以</li>
</ul>
<h1 id="html的元素有哪些（包含H5）？"><a href="#html的元素有哪些（包含H5）？" class="headerlink" title="html的元素有哪些（包含H5）？"></a>html的元素有哪些（包含H5）？</h1><p><strong>行内元素:</strong><br>span - 字符<br>a - 超链接<br><strong>块级元素:</strong><br>head - 头部<br>title - 页面标题<br>body - 内容<br>div -<br>footer - 底部<br>h1-h6 内容标题<br>nav - 侧边栏<br>ul-li - 列表<br>ul-ol - 数字列表<br>hr - 下划线<br>p - 段落<br>form - 表单</p>
<p><strong>空元素:</strong><br>br - 换行<br>hr - 水平线<br>img - 图片<br>input - 输入框<br>link - 外部样式表<br>meta - 页面的元信息<br>area - 图像映射<br>base - 标签为页面上的所有链接规定默认地址或默认目标<br>col - 标签为表格中一个或多个列定义属性值<br>colgroup - 标签用于对表格中的列进行组合，以便对其进行格式化。<br>command - 标记<br>embed - 定义嵌入的内容，比如插件。<br>keygen - 规定用于表单的密钥对生成器字段。<br>param - 添加对象<br>source - 媒介元素<br>track - 为诸如 video 元素之类的媒介规定外部文本轨道。<br>wbr - 在文本中的何处适合添加换行符</p>
<h1 id="简述超链接target属性的取值和作用"><a href="#简述超链接target属性的取值和作用" class="headerlink" title="简述超链接target属性的取值和作用"></a>简述超链接target属性的取值和作用</h1><p>_blank - 在新窗口打开被链接文档<br>_self  - 在相同的框架中打开被链接文档<br>_parent - 在父框架集中打开被链接文档<br>_top - 在整个窗口中打开被链接文档<br>framename - 在指定框架中打开被链接文档</p>
<h1 id="label都有哪些作用？并举相应的例子说明"><a href="#label都有哪些作用？并举相应的例子说明" class="headerlink" title="label都有哪些作用？并举相应的例子说明"></a>label都有哪些作用？并举相应的例子说明</h1><p>可以用来关联表单控件，通过<code>for</code>属性来关联相关元素<code>id</code>属性相同<br>当点击<code>label</code>控件时可以使游览器焦点移动到它绑定的元素上</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;form&gt;</span><br><span class="line">  &lt;label for=&quot;male&quot;&gt;male&lt;/label&gt;</span><br><span class="line">  &lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;male&quot;/&gt;</span><br><span class="line">  &lt;br/&gt;</span><br><span class="line">  &lt;label for=&quot;female&quot;&gt;female&lt;/label&gt;</span><br><span class="line">  &lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;female&quot;/&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>
<h1 id="var-let-const-之间有什么区别？"><a href="#var-let-const-之间有什么区别？" class="headerlink" title="var let const 之间有什么区别？"></a>var let const 之间有什么区别？</h1><p><code>var</code>、<code>let</code>、<code>const</code>三者的区别</p>
<ul>
<li>变量提升</li>
<li>暂时性死区</li>
<li>块级作用域</li>
<li>重复声明</li>
<li>修改声明的变量</li>
<li>使用</li>
</ul>
<h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><p><code>var</code>声明的变量存在变量提升，即变量可以在</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/02/17/interview-01/" data-id="cljfboj3700048cb67wzedw3n" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/html/" rel="tag">html</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2022web前端面试题01" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/02/10/2022web%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9801/" class="article-date">
  <time datetime="2022-02-10T02:26:00.000Z" itemprop="datePublished">2022-02-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/02/10/2022web%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9801/">2022web前端面试题01</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="HTML面试题"><a href="#HTML面试题" class="headerlink" title="HTML面试题"></a>HTML面试题</h2><h3 id="面试题：行内元素有那些？-块级元素有那些？-空（void）元素有那些？"><a href="#面试题：行内元素有那些？-块级元素有那些？-空（void）元素有那些？" class="headerlink" title="面试题：行内元素有那些？ 块级元素有那些？ 空（void）元素有那些？"></a>面试题：行内元素有那些？ 块级元素有那些？ 空（void）元素有那些？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">行内元素： span  img input ...</span><br><span class="line">块级元素:  div  footer header section p h1 ... h6</span><br><span class="line">空元素: br  hr ...</span><br></pre></td></tr></table></figure>
<h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ios日期转换NAN问题</span><br><span class="line">		具体就是，new Date(&#x27;2020-11-12 00:00:00&#x27;)在ios中会为NAN</span><br><span class="line">		解决方案：用new Date(&#x27;2020/11/12 00:00:00&#x27;)的日期格式，或者写个正则转换</span><br><span class="line">在移动端使用click事件有300ms延迟的问题</span><br><span class="line">	 	禁止双击缩放===》meta:user-scalabel=no</span><br><span class="line">移动端touch事件有穿透（点透）的问题，怎么解决？</span><br><span class="line">	 	4.1 阻止默认行为 : e.preventDefault();</span><br><span class="line">	 	4.2 fastclick.js</span><br><span class="line">安卓部分版本input的placeholder偏上</span><br><span class="line">		input&#123;</span><br><span class="line">	  		 line-height:normal;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<h3 id="首屏优化"><a href="#首屏优化" class="headerlink" title="首屏优化"></a>首屏优化</h3><ol>
<li>减少重绘和回流</li>
<li>改变位置使用<code>transform</code></li>
<li>动画尽量用<code>requestAnimationFrame</code>，不要用定时器<h3 id="cookie、localstorage、sessionstrorage之间有什么区别？"><a href="#cookie、localstorage、sessionstrorage之间有什么区别？" class="headerlink" title="cookie、localstorage、sessionstrorage之间有什么区别？"></a><code>cookie</code>、<code>localstorage</code>、<code>sessionstrorage</code>之间有什么区别？</h3></li>
</ol>
<ul>
<li>与服务器交互：<ul>
<li><code>cookie</code> 是网站为了标示用户身份而储存在用户本地终端上的数据（通常经过加密）</li>
<li><code>cookie</code> 始终会在同源 http 请求头中携带（即使不需要），在浏览器和服务器间来回传递</li>
<li><code>sessionStorage</code> 和 <code>localStorage</code> 不会自动把数据发给服务器，仅在本地保存</li>
</ul>
</li>
<li>存储大小：<ul>
<li><code>cookie</code> 数据根据不同浏览器限制，大小一般不能超过 4k</li>
<li><code>sessionStorage</code> 和 <code>localStorage</code> 虽然也有存储大小的限制，但比 <code>cookie</code> 大得多，可以达到 5M 或更大</li>
</ul>
</li>
<li>有期时间：<ul>
<li><code>localStorage</code> 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据</li>
<li><code>sessionStorage</code> 数据在当前浏览器窗口关闭后自动删除</li>
<li><code>cookie</code> 设置的 <code>cookie</code> 过期时间之前一直有效，与浏览器是否关闭无关</li>
</ul>
</li>
</ul>
<h3 id="this-的指向有那些？"><a href="#this-的指向有那些？" class="headerlink" title="this 的指向有那些？"></a>this 的指向有那些？</h3><ol>
<li>普通函数中的 <code>this</code>指向<code>window</code></li>
<li>定时器中的 <code>this</code> 指向 <code>window</code></li>
<li>箭头函数没有 <code>this</code>,它的 <code>this</code> 指向取决于外部环境、</li>
<li>事件中的 <code>this</code> 指向事件的调用者</li>
<li> 构造函数中 <code>this</code> 和原型对象中的 <code>this</code>,都是指向构造函数 <code>new</code> 出来实例对象</li>
<li>类 <code>class</code> 中的 <code>this</code> 指向由 <code>constructor</code> 构造器 <code>new</code> 出来的实例对象</li>
<li>自调用函数中的 <code>this</code> 指向 <code>window</code></li>
</ol>
<h3 id="什么是闭包？手写一个闭包函数？闭包有那些优缺点？"><a href="#什么是闭包？手写一个闭包函数？闭包有那些优缺点？" class="headerlink" title="什么是闭包？手写一个闭包函数？闭包有那些优缺点？"></a>什么是闭包？手写一个闭包函数？闭包有那些优缺点？</h3><p>闭包（closure）指有权访问另一个函数作用域中变量的函数。简单理解就是，一个作用域可以访问另外一个函数内部的局部变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function fn() &#123;</span><br><span class="line">  var num = 10;</span><br><span class="line">  function fun() &#123;</span><br><span class="line">    console.log(num)</span><br><span class="line">  &#125;</span><br><span class="line">  return fun</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var f = fn()</span><br><span class="line">f()</span><br></pre></td></tr></table></figure>
<p><strong>作用:</strong> 延长变量作用域、在函数的外部可以访问函数内部的局部变量，容易造成内层泄露，因为闭包中的局部变量永远不会被回收</p>
<p>文章来自：<br><br><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/7060738592741523464">https://juejin.cn/post/7060738592741523464</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/7056400571967733774">https://juejin.cn/post/7056400571967733774</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/02/10/2022web%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9801/" data-id="cljfboj2z00008cb66zkbbbpw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-typescript-day04" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/01/21/typescript-day04/" class="article-date">
  <time datetime="2022-01-21T01:44:47.000Z" itemprop="datePublished">2022-01-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/01/21/typescript-day04/">typescript-day04</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><h2 id="类-1"><a href="#类-1" class="headerlink" title="类"></a>类</h2><p>下面看一个使用类的例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Greeter &#123;</span><br><span class="line">  greeting: string;</span><br><span class="line">  constructor (message: string) &#123;</span><br><span class="line">    this.greeting = message</span><br><span class="line">  &#125;</span><br><span class="line">  greet()&#123;</span><br><span class="line">    return &#x27;Hello,&#x27; + this.greeting;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let greeter = new Greeter(&#x27;world&#x27;);</span><br></pre></td></tr></table></figure>
<p>这个类有3个成员：一个叫做<code>greeting</code>的属性，一个构造函数和一个<code>greet</code>方法。<br>你会注意到，我们在引用任何一个类成员的时候都用了<code>this</code>。它表示我们访问的是类的成员。<br>最后一行，我们使用<code>new</code>构造了<code>Greeter</code>类的一个实例。它会调用之前定义的构造函数，创建一个<code>Greeter</code>类型的新对象，并执行构造函数初始化它。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">  move(distanceInMeters: number = 0) &#123;</span><br><span class="line">    conosle.log(&#x27;Animal moved $&#123;distanceInMeters&#125;m.`&#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog extends Animal &#123;</span><br><span class="line">  bark() &#123;</span><br><span class="line">    console.log(&#x27;Woof! Woof!&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const dog = new Dog();</span><br><span class="line">dog.bark();</span><br><span class="line">dog.move(10);</span><br><span class="line">dog.bark();</span><br></pre></td></tr></table></figure>
<p>这个例子展示了最基本的继承；类从基类中继承了属性和方法。这里，<code>Dog</code>是一个派生类，它派生自<code>Animal</code>基类，通过<code>extends</code>关键字。派生类通常被称为子类，基类通常被称作超类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  constructor (theName: string) &#123; this.name = thisName; &#125;</span><br><span class="line">  move(distanceInMeters: number = 0) &#123;</span><br><span class="line">    console.log(`$&#123;this.name&#125; moved $&#123;distanceInMeters&#125;m.`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Snake extends Animal &#123;</span><br><span class="line">  constructor(name: string) &#123; super(name); &#125;</span><br><span class="line">  move(distanceInMeters = 5) &#123;</span><br><span class="line">    console.log(&#x27;Slithring...&#x27;);</span><br><span class="line">    super.move(distanceInMeters);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Horse extends Animal &#123;</span><br><span class="line">  constructor(name: string) &#123; super(name); &#125;</span><br><span class="line">  move(distanceInMeters = 45) &#123;</span><br><span class="line">    console.log(&quot;Galloping...&quot;);</span><br><span class="line">    super.move(distanceInMeters);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let sam = new Snake(&quot;Sammy the Python&quot;);</span><br><span class="line">let tom: Animal = new Horse(&quot;Tommy the Palomino&quot;);</span><br><span class="line"></span><br><span class="line">sam.move();</span><br><span class="line">tom.move(34);</span><br></pre></td></tr></table></figure>
<p>派生类包含了一个构造函数，它必须调用<code>super()</code>，它会执行基类的构造函数。而且，在构造函数里访问<code>this</code>的属性之前，我们一定要调用<code>super()</code>。</p>
<p>这个例子演示了如何在子类里可以重写父类的方法。<code>Snake</code>类和<code>Horse</code>类都创建了<code>move</code>方法，它们重写了从<code>Animal</code>继承类的<code>move</code>方法，使得<code>move</code>方法根据不同的类而具有不同的功能。注意，即使<code>tom</code>被声明为<code>Animal</code>类型，但因为它的值是<code>Horse</code>，调用<code>tom.move(34)</code>时，它会调用<code>Horse</code>里重写的方法:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Slithering...</span><br><span class="line">Sammy the Python moved 5m.</span><br><span class="line">Galloping...</span><br><span class="line">Tommy the Palomino moved 34m.</span><br></pre></td></tr></table></figure>
<h2 id="公共，私有与受保护的修饰符"><a href="#公共，私有与受保护的修饰符" class="headerlink" title="公共，私有与受保护的修饰符"></a>公共，私有与受保护的修饰符</h2><h3 id="默认为-public"><a href="#默认为-public" class="headerlink" title="默认为 public"></a>默认为 <code>public</code></h3><p>在上面的例子里，我们可以自由的访问程序里定义的成员。如果你对其他语言中的类比较了解，就会注意到我们之前的代码里没有使用<code>public</code>来做修饰；在TypeScript里，成员都默认为<code>public</code>。<br>你也可以明确的将一个成员标记成<code>public</code>。我们可以用下面的方式来重写上面的<code>Animal</code>类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">  public name: string;</span><br><span class="line">  public constructor (theName: string) &#123; this.name = theName; &#125;</span><br><span class="line">  public move(distanceInMeters: number) &#123;</span><br><span class="line">    console.log(`$&#123;this.name&#125; moved $&#123;distanceInMeters&#125;m`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="理解private"><a href="#理解private" class="headerlink" title="理解private"></a>理解<code>private</code></h3><p>当成员被标记成<code>private</code>时，它就不能在声明它的类的外部访问。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">  private name: string;</span><br><span class="line">  constructor(theName: string) &#123; this.name = theName ;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new Animal(&quot;cat&quot;).name; // 错误的 name 是私有的</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>TypeScript 使用的是结构性类型系统。当我们比较两种不同的类型时，并不在乎它们从何处而来，如果所有成员的类型都是兼容的，我们就认为它们的类型是兼容的。<br>然而，当我们比较带有<code>private</code>或<code>protected</code>成员的类型的时候，情况就不同了。如果其中一个类型里包含一个<code>private</code>成员，那么只有当另外一个类型中也存在这样一个<code>private</code>成员，并且它们都是来自同一处声明时，我们才认为这两个类型是兼容的。对于<code>protected</code>成员也使用这个规则.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">  private name: string;</span><br><span class="line">  constructor(theName: string) &#123;</span><br><span class="line">    this.name = theName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Rhino extends Animal &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super(&quot;Rhino&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Employee &#123;</span><br><span class="line">  private name: string;</span><br><span class="line">  constructor(theName: string) &#123;</span><br><span class="line">    this.name = theName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let animal = new Animal(&quot;Goat&quot;);</span><br><span class="line">let rhino = new Rhino();</span><br><span class="line">let employee = new Employee(&quot;Bob&quot;);</span><br><span class="line"></span><br><span class="line">animal = rhino;</span><br><span class="line">animal = employee; //错误：Animal 和 Employee 不兼容</span><br></pre></td></tr></table></figure>
<h3 id="理解protected"><a href="#理解protected" class="headerlink" title="理解protected"></a>理解<code>protected</code></h3><p><code>protected</code>修饰符与<code>private</code>修饰符的行为很相似，但有一点不同，<code>protected</code>成员在派生类中仍然可以访问。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  protected name: string;</span><br><span class="line">  constructor(name: string) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Employee extends Person &#123;</span><br><span class="line">  private department: string;</span><br><span class="line">  constructor(name: string, department: string) &#123;</span><br><span class="line">    super(name)</span><br><span class="line">    this.department = department;</span><br><span class="line">  &#125;</span><br><span class="line">  public getElevatorPitch() &#123;</span><br><span class="line">    return `Hello , my name is $&#123;this.name&#125; and I work in $&#123;this.department&#125;.`;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let howard = new Employee(&#x27;Howard&#x27;,&#x27;Sales&#x27;);</span><br><span class="line">console.log(howard.getElevatorPitch());</span><br><span class="line">console.log(howard.name); //错误</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/01/21/typescript-day04/" data-id="cljfboj3d000d8cb66kquchyj" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-typescript-day03" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/01/18/typescript-day03/" class="article-date">
  <time datetime="2022-01-18T07:15:46.000Z" itemprop="datePublished">2022-01-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/01/18/typescript-day03/">typescript-day03</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><h2 id="接口初探"><a href="#接口初探" class="headerlink" title="接口初探"></a>接口初探</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function printLabel(labelledObj: &#123; label: string&#125;) &#123;</span><br><span class="line">  console.log(labelledObj.label);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let myObj = &#123; size: 10, label: &quot;size 10 Object&quot; &#125;;</span><br><span class="line">printLabel(myObj);</span><br></pre></td></tr></table></figure>
<p>类型检查器会查看<code>printLabel</code>的调用。<code>printLabel</code>有一个参数,并要求这个对象参数有一个名为<code>label</code>类型为<code>string</code>的属性。需要注意的是，我们传入的对象参数实际上会包含很多属性,但是编译器只会检查哪些必须的属性是否存在，并且其类型是否匹配。</p>
<p>下面我们重写上面的例子，这次试用接口来描述：必须包含一个<code>label</code>属性且类型为<code>string</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interface LabelledValue &#123;</span><br><span class="line">  label: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function printLabel(labelledObj: LabelledValue) &#123;</span><br><span class="line">  console.log(labelledObj.label);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let myObj = &#123; size: 10, label: &quot;Size 10 Object&quot;&#125;;</span><br><span class="line">printLabel(myObj);</span><br></pre></td></tr></table></figure>
<p><code>LabelledValue</code>接口就好比一个名字，用来描述上面例子里的要求。它代表了有一个<code>label</code>属性且类型为<code>string</code>的对象。需要注意的是,我们在这里并不能像在其他语言里一样，说传给<code>printLabel</code>的对象实现了这个接口。我们只会去关注值的外形。只要传入的对象满足上面提到的必要条件，那么它就是被允许的。</p>
<p>还有一点值得提的是，类型检查器不会去检查属性的顺序，只要相应的属性存在并且也是对的就可以。</p>
<h2 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h2><p>接口里的属性不全都是必须的。有些是只在某些条件下存在，或者根本不存在。可选属性在应用”option bags”模式时很常用，即给函数传入的参数对象中只有部分属性赋值了。</p>
<p>下面是应用了”option bags”的例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">interface SquareConfig &#123;</span><br><span class="line">  color?: string;</span><br><span class="line">  width?: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function createSquare(config: SquareConfig): &#123;color: string, area: number&#125; &#123;</span><br><span class="line">  let newSquare - &#123;color: &quot;white&quot;, area: 100&#125;;</span><br><span class="line">  if (config.color) &#123;</span><br><span class="line">    newSquare.color = config.color;</span><br><span class="line">  &#125;</span><br><span class="line">  if (config.width) &#123;</span><br><span class="line">    newSquare.area = config.width * config.width;</span><br><span class="line">  &#125;</span><br><span class="line">  return newSquare;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let mySquare = createSquare(&#123;color: &quot;black&quot;&#125;)</span><br></pre></td></tr></table></figure>
<p>带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个<code>?</code>符号。</p>
<p>可选属性的好处之一是对可能存在的属性进行预定义，好处之二是可以捕获引用了不存在属性时的错误。</p>
<h2 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h2><p>一些对象属性只能在对象刚刚创建的时候修改其值。你可以在属性名前用<code>readonly</code>来指定只读属性；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface Point &#123;</span><br><span class="line">  readonly x: number;</span><br><span class="line">  readonly y: number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以通过赋值一个对象字面量来构造一个<code>Point</code>，赋值后，<code>x</code>和<code>y</code>再也不能改变了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let p1:Ponit = &#123;x: 10, y: 20&#125;;</span><br><span class="line">p1.x = 5 // Error</span><br></pre></td></tr></table></figure>
<p>TypeScript 具有 <code>ReadonlyArray&lt;T&gt;</code> 类型，它与<code>Array&lt;T&gt;</code>相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改；</p>
<h3 id="readonly-VS-const"><a href="#readonly-VS-const" class="headerlink" title="readonly VS const"></a><code>readonly</code> VS <code>const</code></h3><p>最简单判断该用  <code>readonly</code>还是<code>const</code>的方法是看要把它做为变量使用还是作为一个属性。做为变量使用的话用<code>const</code>，若做为属性使用<code>readonly</code>。</p>
<h2 id="额外的属性检查"><a href="#额外的属性检查" class="headerlink" title="额外的属性检查"></a>额外的属性检查</h2><p>我们在第一个例子里使用了接口，TypeScript让我们传入<code>&#123; size: number, label: string&#125;</code>到仅期望得到<code>&#123;label: string&#125;</code>的函数里。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">interface SquareConfig &#123;</span><br><span class="line">  color?: string;</span><br><span class="line">  width?: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function createSquare(config: SquareConfig): &#123;color: string; area: number&#125; &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// error： &quot;color&quot; not expected in type &quot;SquareConfig&quot;</span><br><span class="line">let mySquare = createSquare(&#123; colour: &quot;red&quot;, width: 100&#125;);</span><br></pre></td></tr></table></figure>
<p>注意传入<code>createSquare</code>的参数拼写为<code>colour</code>而不是<code>color</code>。在JavaScrit里，这会失败。</p>
<p>最佳的方式是能添加一个字符串索引签名，前提是你能够确定这个对象可能具有某些做为特殊用途使用的额外属性。如果<code>SquareConfig</code>带有上面定义的类型<code>color</code>和<code>width</code>属性，并且还会带有任意数量的其他属性，那么我们可以这样定义它：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface SquareConfig &#123;</span><br><span class="line">  color?: string;</span><br><span class="line">  width?: number;</span><br><span class="line">  [propName: string]: any;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h2><p>接口能够描述JavaScript中对象拥有的各种各样的外形。除了描述带有属性的普通对象外，接口也可以描述函数类型。</p>
<p>为了使用接口表示函数类型，我们需要给接口定义一个调用签名。它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface SearchFunc &#123;</span><br><span class="line">  &#123;source: string, subString: string&#125;: boolean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样定义后，我们可以像使用其他接口一样使用这个函数类型的接口。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let mySearch: SearchFunc;</span><br><span class="line">mySearch = function (source: string, subString: string) &#123;</span><br><span class="line">  let result = source.search(subString);</span><br><span class="line">  return result &gt; -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于函数类型的类型检查来说，函数的参数名不需要与接口里定义的名字相匹配。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let mySearch:SearchFunc;</span><br><span class="line">mySearch = function(src: string, sub: string): boolean &#123;</span><br><span class="line">  let result = src.serach(sub);</span><br><span class="line">  return result &gt; -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数的参数会逐个进行检查，要求对应位置上的参数类型是兼容的。如果你不想指定类型，TypeScript的类型系统会推断出参数类型，因为函数直接赋值给了<code>SearchFunc</code>类型变量。函数的返回值类型是通过其返回值推断出来的(此例是<code>false</code>和<code>true</code>)。如果让这个函数返回数字或字符串，类型检查器会警告我们函数的返回值类型与<code>SearchFunc</code>接口中的定义不匹配。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let mySearch: SearchFunc;</span><br><span class="line">mySearch = function(src, sub) &#123;</span><br><span class="line">  let result = src.search(sub);</span><br><span class="line">  return result &gt; -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="可索引的类型"><a href="#可索引的类型" class="headerlink" title="可索引的类型"></a>可索引的类型</h2><p>与使用接口描述函数类型差不多，我们也可以描述那些能够“通过索引得到”的类型，比如<code>a[10]</code>或<code>ageMap[&quot;daniel&quot;]</code>.可索引类型具有一个索引标签，它描述了对象索引的类型，还有相应的索引返回值类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface StringArray &#123;</span><br><span class="line">  [index: number]: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let myArray: StringArray;</span><br><span class="line">myArray = [&quot;Bob&quot;, &quot;Fred&quot;];</span><br><span class="line"></span><br><span class="line">let myStr: string = myArray[0];</span><br></pre></td></tr></table></figure>
<p>上面例子里，我们定义了<code>StringArray</code>接口,它具有索引签名。这个索引签名表示了当用<code>number</code>去索引<code>StringArray</code>时会得到<code>string</code>类型的返回值.</p>
<p>TypeScript支持两种索引签名:字符串和数字。可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。这是因为当使用<code>number</code>来索引时，JavaScript会将它转换成<code>string</code>然后再去索引对象。也就是说用<code>100</code>(一个<code>number</code>)去索引等同于使用<code>&quot;100&quot;</code>（一个<code>string</code>）去索引，因此两者需要保持一致。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">  name: string;</span><br><span class="line">&#125;</span><br><span class="line">class Dog extends Animal &#123;</span><br><span class="line">  breed: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 错误：使用数值型的字符串索引，有时会得到完全不用的Animal</span><br><span class="line">interface NotOkay &#123;</span><br><span class="line">  [x: number]: Animal;</span><br><span class="line">  [x: string]: Dog;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>字符串索引签名能够很好的描述<code>dictionary</code>模式，并且它们也会确保所有属性与其返回值类型相匹配。因为字符串索引声明了<code>obj.property</code>和<code>obj[&quot;property&quot;]</code>两种形式都可以。下面的例子里，<code>name</code>的类型与字符串索引类型不匹配，所以类型检查器给出一个错误提示:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface NumberDictionary &#123;</span><br><span class="line">  [index: string]: number;</span><br><span class="line">  length: number; // 可以,length是number类型</span><br><span class="line">  name: string    // 错误 &#x27;name&#x27;的类型与索引类型返回值的类型不匹配</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最后，你可以将索引签名设置为只读，这样就防止了给索引赋值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface ReadonlyStringArray &#123;</span><br><span class="line">  readonly [index: number]: string;</span><br><span class="line">&#125;</span><br><span class="line">let myArray: ReadonlyStringArray = [&#x27;Alice&#x27;, &#x27;Bob&#x27;];</span><br><span class="line">myArray[2] = &#x27;Mallory&#x27; // Error</span><br></pre></td></tr></table></figure>
<p>你不能设置<code>myArray[2]</code>,因为索引签名是只读的.</p>
<h2 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h2><h3 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h3><p>与C#或者Java里接口的基本作用一样，TypeScript也能够用它来明确的强制一个类去符合某种契约</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface ClockInterface &#123;</span><br><span class="line">  currentTime: Date;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Clock implements ClockInterface &#123;</span><br><span class="line">  currentTime: Date;</span><br><span class="line">  constructor(h: number, m: number) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你也可以在接口中描述一个方法，在类里实现它，如同下面的<code>setTime</code>方法一样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">interface ClockInterface &#123;</span><br><span class="line">  currentTime: Date;</span><br><span class="line">  setTime(d: Date);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Clock implements ClockInterface &#123;</span><br><span class="line">  currentTime: Date;</span><br><span class="line">  setTime(d: Date) &#123;</span><br><span class="line">    this.currentTime = d;</span><br><span class="line">  &#125;</span><br><span class="line">  constructor(h: number, m: number) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口描述了类的公共部分，而不是公共和私有两部分。它不会帮你检查类是否具有某些私有成员。</p>
<h3 id="类静态部分与实例部分的区别"><a href="#类静态部分与实例部分的区别" class="headerlink" title="类静态部分与实例部分的区别"></a>类静态部分与实例部分的区别</h3><p>当你操作类和接口的时候，你要知道类是具有两个类型的；静态部分的类型和实例的类型，当你用构造器签名去定义一个接口并试图定义一个类去实现这个接口时会得到一个错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface ClockConstructor &#123;</span><br><span class="line">  new (hour: number, minute: number);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Clock implements ClockConstructor &#123;</span><br><span class="line">  currentTime: Date;</span><br><span class="line">  constructor(h: number, m: number) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里因为当一个类实现了一个接口时，只对其实例部分进行类型检查。constructor存在与类的静态部分，所以不再检查的范围内。</p>
<p>因此，我们应该直接操作类的静态部分。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">interface ClockConstructor &#123;</span><br><span class="line">  new (hour: number, minute: number): ClockInterface;</span><br><span class="line">&#125;</span><br><span class="line">interface ClockInterface &#123;</span><br><span class="line">  tick()</span><br><span class="line">&#125;</span><br><span class="line">function createClock (ctor: ClockConstructor, hour: number, minute: number): ClockInterface &#123;</span><br><span class="line">  return new ctor(hour, minute);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class DigtalClock implements ClockInterface &#123;</span><br><span class="line">  constructor(h: number, m: number);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class DigtalClock implements ClockInterface &#123;</span><br><span class="line">  constructor(h: number, m: number);</span><br><span class="line">  tick() &#123;</span><br><span class="line">    console.log(&quot;beep beep&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class AnalogClock implements ClockInterface &#123;</span><br><span class="line">  constructor(h: number, m: number) &#123; &#125;</span><br><span class="line">  tick() &#123;</span><br><span class="line">    console.log(&quot;tick tock&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let digital = createClock(DigtalClock, 12, 17);</span><br><span class="line">let analog = createClock(AnalogClick, 7, 32);</span><br></pre></td></tr></table></figure>
<p>因为<code>createClock</code>的第一个参数是<code>ClockConstructor</code>类型，在<code>createClock(AnalogClock, 7, 32)</code>里，会检查<code>AnalogClock</code>是否符合构造函数签名.</p>
<h2 id="继承接口"><a href="#继承接口" class="headerlink" title="继承接口"></a>继承接口</h2><p>和类一样，接口也可以相互继承。这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活将接口分割到可重用的模块里。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">interface Shape &#123;</span><br><span class="line">  color: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Square extends Shape &#123;</span><br><span class="line">  sideLength: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let square = &lt;Square&gt;();</span><br><span class="line">square.color = &quot;blue&quot;;</span><br><span class="line">square.sideLength = 10;</span><br></pre></td></tr></table></figure>
<p>一个接口可以继承多个接口，创建出多个接口的合成接口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">interface Shape &#123;</span><br><span class="line">  color: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface PenStroke &#123;</span><br><span class="line">  penWidth: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Square extends Shape, PenStroke &#123;</span><br><span class="line">  sideLength: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let square = &lt;Square&gt;();</span><br><span class="line">square.color = &quot;blue&quot;;</span><br><span class="line">square.sideLength = 10;</span><br><span class="line">square.penWidth = 5.0;</span><br></pre></td></tr></table></figure>
<h2 id="混合类型"><a href="#混合类型" class="headerlink" title="混合类型"></a>混合类型</h2><p>一个例子，一个对象可以同时做为函数和对象使用，并带有额外的属性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">interface Counter &#123;</span><br><span class="line">  (start: number): string;</span><br><span class="line">  interval: number;</span><br><span class="line">  reset(): void;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getCount(): Counter &#123;</span><br><span class="line">  let counter = &lt;Counter&gt; function (start: number) &#123; &#125;;</span><br><span class="line">  counter.interval = 22;</span><br><span class="line">  counter.reset = function () &#123; &#125;;</span><br><span class="line">  return counter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let c = getCounter();</span><br><span class="line">c(10);</span><br><span class="line">c.reset();</span><br><span class="line">c.interval = 5.0;</span><br></pre></td></tr></table></figure>
<h2 id="接口继承类"><a href="#接口继承类" class="headerlink" title="接口继承类"></a>接口继承类</h2><p>当接口继承了一个类类型时，它会继承类的成员但不包括实现。就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。接口同样会继承到类的<code>private</code>和<code>proteceed</code>成员。这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现(implement).</p>
<p>当你有一个庞大的继承结构时这很有用，但要指出的是你的代码只在子类拥有特定属性时起作用。这个子类除了继承基类外与基类没有任何关系。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Control &#123;</span><br><span class="line">  private state: any;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface SelectableControl extends Control &#123;</span><br><span class="line">  select(): void;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Button extends Control implements SelectableControl &#123;</span><br><span class="line">  select() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class TextBox extends Control &#123;</span><br><span class="line">  select () &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// error Image 类型缺少 state 属性</span><br><span class="line">class Image implements SelectableControl &#123;</span><br><span class="line">  select() &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Location &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/01/18/typescript-day03/" data-id="cljfboj3b000a8cb682bw9bbh" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-typescript-day02" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/01/18/typescript-day02/" class="article-date">
  <time datetime="2022-01-18T06:51:31.000Z" itemprop="datePublished">2022-01-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/01/18/typescript-day02/">typescript-day02</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h1><h2 id="变量声明-1"><a href="#变量声明-1" class="headerlink" title="变量声明"></a>变量声明</h2><p><code>let</code>和<code>const</code>是JavaScript里相对较新的变量声明方式。<code>let</code>在很多方面与<code>var</code>是相似的,但是可以帮助大家避免在JavaScript里常见一些问题。<code>const</code>是对<code>let</code>的一个增强，它能阻止对一个变量再次赋值。</p>
<h2 id="var声明"><a href="#var声明" class="headerlink" title="var声明"></a><code>var</code>声明</h2><p>一直以来我们都是通过<code>var</code>关键字定义JavaScript变量.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">var a = 10;</span><br><span class="line"></span><br><span class="line">function f()&#123;</span><br><span class="line">  var message = &quot;Hello world!&quot;;</span><br><span class="line">  return message;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function f()&#123;</span><br><span class="line">  var a = 10;</span><br><span class="line">  return function g()&#123;</span><br><span class="line">    var b = a + 1;</span><br><span class="line">    return b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var g = f();</span><br><span class="line">g(); // return 11;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function f() &#123;</span><br><span class="line">  var a = 1;</span><br><span class="line">  a = 2;</span><br><span class="line">  var b = g();</span><br><span class="line">  a = 3;</span><br><span class="line">  return b;</span><br><span class="line"></span><br><span class="line">  function g()&#123;</span><br><span class="line">    return a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">f(); // return 2</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="作用域规则"><a href="#作用域规则" class="headerlink" title="作用域规则"></a>作用域规则</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function f(shouldInitialize: boolean) &#123;</span><br><span class="line">  if (shouldInitialize) &#123;</span><br><span class="line">    var x = 10;</span><br><span class="line">  &#125;</span><br><span class="line">  return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(true); // return &#x27;10&#x27;</span><br><span class="line">f(false); // return &#x27;undefined&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="捕获变量怪异之处"><a href="#捕获变量怪异之处" class="headerlink" title="捕获变量怪异之处"></a>捕获变量怪异之处</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">for (var i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">  setTimeout(function () &#123;console.log(i);&#125;, 100 * i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果为:</span><br><span class="line">10</span><br><span class="line">10</span><br><span class="line">10</span><br><span class="line">10</span><br><span class="line">10</span><br><span class="line">10</span><br><span class="line">10</span><br><span class="line">10</span><br><span class="line">10</span><br><span class="line">10</span><br><span class="line"></span><br><span class="line">我们传给setTimeout的每一个函数表达式实际上都引用了相同作用域里的同一个i。</span><br><span class="line">一个通常的解决方案是使用立即执行的函数表达式(IIFE)</span><br><span class="line">for (var i =0; i&lt; 0; i++) &#123;</span><br><span class="line">  (function (i)&#123;</span><br><span class="line">    setTimeout(function() &#123; console.log(i); &#125;, 100 * i)</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="let声明"><a href="#let声明" class="headerlink" title="let声明"></a><code>let</code>声明</h2><h3 id="块作用域"><a href="#块作用域" class="headerlink" title="块作用域"></a>块作用域</h3><p>当用<code>let</code>声明一个变量，它使用的是词法作用域或块作用域.不同于使用<code>var</code>声明的变量那样可以在包含它们的函数外访问，块作用域变量在包含它们块或<code>for</code>循环之外是不能访问的.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function f(input: boolean) &#123;</span><br><span class="line">  let a = 100;</span><br><span class="line">  if (input) &#123;</span><br><span class="line">    let b = a + 1;</span><br><span class="line">    return b;</span><br><span class="line">  &#125;</span><br><span class="line">  return b // Error &#x27;b&#x27; doesn&#x27;t exist here</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>catch</code>语句里声明的变量也具有同样的作用域规则</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">  throw &quot;oh no!&quot;;</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">  console.log(&quot;Oh well&quot;);</span><br><span class="line">&#125;</span><br><span class="line">console.log(e) // Error &#x27;e&#x27; doesn&#x27;t exist here</span><br></pre></td></tr></table></figure>
<p>拥有块级作用域的变量的另一个特点是，它们不能被声明之前读或写。虽然这些变量始终“存在”于它们的作用域里，但在直到声明它的代码之前的区域都属于<strong>暂时性死区</strong></p>
<h3 id="重定义及屏蔽"><a href="#重定义及屏蔽" class="headerlink" title="重定义及屏蔽"></a>重定义及屏蔽</h3><p>我们提过使用<code>var</code>声明时，它不在乎你声明多少次，你只会得到1个</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function f(x) &#123;</span><br><span class="line">  var x;</span><br><span class="line">  var x;</span><br><span class="line">  if (true) &#123;</span><br><span class="line">    var x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="const声明"><a href="#const声明" class="headerlink" title="const声明"></a><code>const</code>声明</h2><p><code>const</code>声明是声明变量的另一种方式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const numLivesForCat = 9;</span><br></pre></td></tr></table></figure>
<p>它们与<code>let</code>声明相似，但是就像它的名字所表达的，它们被赋值后不能再改变。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/01/18/typescript-day02/" data-id="cljfboj3a00098cb6b93q5rmg" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-typescript-day01" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/01/18/typescript-day01/" class="article-date">
  <time datetime="2022-01-18T03:17:55.000Z" itemprop="datePublished">2022-01-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/01/18/typescript-day01/">typescript-day01</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h1><h2 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h2><p>最基本的数据类型就是简单的 true/false </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let isDone: boolean = false;</span><br></pre></td></tr></table></figure>

<h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><p>和javaScript一样，TypeScript 里所有的数字都是浮点数。这些浮点数的类型是 <code>number</code>。 除了支持十进制和十六进制字面量， TypeScript 还支持 ECMAScript 2015中引入的二进制和八进制字面量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let a: number = 6;</span><br><span class="line">let b: number = 0xf00d;</span><br><span class="line">let c: number = 0b1010;</span><br><span class="line">let d: number = 0o744;</span><br></pre></td></tr></table></figure>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>不仅支持双引号(<code>&quot;</code>)或单引号(<code>&#39;</code>)。还可以使用模版字符串</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let name: string = &quot;bob&quot;;</span><br><span class="line">name = &#x27;smith&#x27;</span><br><span class="line"></span><br><span class="line">let name: string = `Gene`;</span><br><span class="line">let age: number = 37;</span><br><span class="line">let sentence: string = `Hello, my name is $&#123; name &#125;.</span><br><span class="line">I&#x27;ll be $&#123;age + 1&#125; years old next month.`;</span><br></pre></td></tr></table></figure>

<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let list: number[] = [1, 2, 3];</span><br><span class="line">let list: Array&lt;number&gt; = [1, 2, 3]</span><br></pre></td></tr></table></figure>

<h2 id="元组-Tuple"><a href="#元组-Tuple" class="headerlink" title="元组 Tuple"></a>元组 Tuple</h2><p>元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let x: [string, number];</span><br><span class="line">x = [&#x27;hello&#x27;, 10]; // ok</span><br><span class="line">x = [1, &#x27;hello&#x27;] // error</span><br><span class="line"></span><br><span class="line">当访问一个已知索引的元素，会得到正确的类型</span><br><span class="line">console.log(x[0].substr(1)); // ok</span><br><span class="line">console.log(x[1].substr(1)); // Error, &#x27;number&#x27; does not have &#x27;substr&#x27; </span><br><span class="line"></span><br><span class="line">当访问一个越界的元素，会使用联合类型替代；</span><br><span class="line">x[3] = &#x27;world&#x27;; // ok  字符串可以赋值给(string | number) 类型</span><br><span class="line">console.log(x[5].toString()); // ok &#x27;string&#x27; 和 &#x27;number&#x27; 都有 toString</span><br><span class="line">x[6] = true // error 布尔不是(string | number) 类型</span><br></pre></td></tr></table></figure>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p><code>enum</code>类型是对JavaScript 标准数据类型的一个补充。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">enum Color &#123;Red, Green, Blue&#125;</span><br><span class="line">let c: Color = Color.Green;</span><br><span class="line"></span><br><span class="line">默认情况下，从0开始为元素编号。</span><br><span class="line"></span><br><span class="line">enum Color &#123;Red = 1, Green, Blue&#125;</span><br><span class="line">let c: Color = Color.Green;</span><br><span class="line"></span><br><span class="line">或者，全部都采用手动赋值：</span><br><span class="line"></span><br><span class="line">enum Color &#123;Red = 1, Green = 2, Blue = 4&#125;</span><br><span class="line">let c: Color = Color.Green;</span><br><span class="line"></span><br><span class="line">枚举类型提供的一个便利是你可以由枚举值得到它的名字。例如，我们知道数值为2，但是不确定它映射到Color里都那个名字，我们可以查找相应的名字；</span><br><span class="line"></span><br><span class="line">enum Color &#123;Red = 1, Green, Bule&#125;</span><br><span class="line">let colorName: string = Color[2];</span><br><span class="line">console.log(colorName); // 显示&#x27;Green&#x27;因为上面代码里的值是2</span><br></pre></td></tr></table></figure>

<h2 id="Any"><a href="#Any" class="headerlink" title="Any"></a>Any</h2><p>有时候，我们会想要那些在编程阶段还不清楚类型的变量指定一个类型。这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查，那么我们可以使用<code>any</code>类型来标记这些变量；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let notSure: any = 4;</span><br><span class="line">notSure = &#x27;maybe a string instead&#x27;;</span><br><span class="line">notSure = false; // ok definitely a boolean</span><br><span class="line"></span><br><span class="line">但是不能够在它上面调用任意的方法，即使它真的有这些方法：</span><br><span class="line"></span><br><span class="line">let notSure: any = 4;</span><br><span class="line">notSure.ifItExists(); // okay, ifItExists might exist at runtime</span><br><span class="line">notSure.toFixed(); // okay, toFixed exists (but the compiler doesn&#x27;t check)</span><br><span class="line"></span><br><span class="line">let prettySure: Object = 4;</span><br><span class="line">prettySure.toFixed(); // Error: Property &#x27;toFixed&#x27; doesn&#x27;t exist on type &#x27;Object&#x27;.</span><br></pre></td></tr></table></figure>
<p>当你只知道一部分数据的类型时，<code>any</code>类型也是有用的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let list: any[] = [1, true, &quot;free&quot;];</span><br><span class="line">list[1] = 100;</span><br></pre></td></tr></table></figure>

<h2 id="Void"><a href="#Void" class="headerlink" title="Void"></a>Void</h2><p>某种程度上说，<code>void</code>类型像是与<code>any</code>类型相反，它表示没有任何类型。当一个函数没有返回值时，你通常会见到其返回值类型是 void;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function warnUser(): void &#123;</span><br><span class="line">  console.log(&quot;This is my warning message&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>声明一个<code>void</code>类型的变量没有什么大用，因为你只能为它赋值<code>undefined</code>和<code>null</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let unusable: void = undefined;</span><br></pre></td></tr></table></figure>

<h2 id="Null-和-Undefined"><a href="#Null-和-Undefined" class="headerlink" title="Null 和 Undefined"></a>Null 和 Undefined</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let u: undefined = undefined;</span><br><span class="line">let n: null = null;</span><br></pre></td></tr></table></figure>
<p>默认情况下<code>null</code>和<code>undefined</code>是所有类型的子类型。<br><code>--strictNullChecks</code>标记，<code>null</code>和<code>undefined</code>只能赋值给<code>void</code>和它们各自。</p>
<h2 id="Never"><a href="#Never" class="headerlink" title="Never"></a>Never</h2><p><code>never</code>类型表示的是那些永不存在的值类型。例如，<code>never</code>类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型；变量也可能是<code>never</code>类型，当它们永不为真的类型保护所约束时。<br><code>never</code>类型是任何类型的子类型,也可以赋值给任何类型；然而，没有类型是<code>never</code>的子类型或可以赋值给<code>never</code>类型.即使<code>any</code>也不可以赋值给<code>never</code>.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 返回的never的函数必须存在无法达到的终点</span><br><span class="line">function error (message: string): never &#123;</span><br><span class="line">  throw new Error(message)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 推断的返回类型是never</span><br><span class="line">function fail()&#123;</span><br><span class="line">  return error(&quot;Something failed);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 返回never的函数必须存在无法达到的终点</span><br><span class="line">function infiniteLoop (): never &#123;</span><br><span class="line">  while(true)&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><p><code>object</code>表示非与那时类型，也就是除了number, string, boolean, symobl, nbull 或<code>undefined外的类型。 使用</code>object<code>类型，就可以更好的表示像</code>Object.create`这样的API</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">declare function create(o: object | null): void;</span><br><span class="line"></span><br><span class="line">create(&#123; prop: 0 &#125;); //ok</span><br><span class="line">create(null); //ok</span><br><span class="line"></span><br><span class="line">create(42); //Error</span><br><span class="line">create(&quot;string&quot;); // Error</span><br><span class="line">create(false); // Error</span><br><span class="line">create(undefined); // Error</span><br></pre></td></tr></table></figure>
<h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><p>类型断言有两种形式.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let someValue: any = &quot;this is a string&quot;</span><br><span class="line"></span><br><span class="line">let strLength: number = (&lt;string&gt;someValue).length;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>另一个为<code>as</code>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let someValue: any = &quot;this is a string&quot;</span><br><span class="line">let strLength: number = (someValue as string).length;</span><br></pre></td></tr></table></figure>
<h2 id="关于let"><a href="#关于let" class="headerlink" title="关于let"></a>关于<code>let</code></h2><p>使用 <code>let</code>来代替<code>var</code></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/01/18/typescript-day01/" data-id="cljfboj3900088cb67w73bfh4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-flex" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/01/17/flex/" class="article-date">
  <time datetime="2022-01-17T02:28:43.000Z" itemprop="datePublished">2022-01-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/01/17/flex/">Flex 布局是什么？</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Flexible Box 模型， 通常被称为 flexbox ，是一种一维的布局模型。它给 flexbox 的子元素之间提供了强大的空间分布和对齐能力。</p>
<p>我们说 flexbox 是一种一维的布局，是因为一个 flexbox 一次只能处理一个维度上的元素布局，一行或者一列。作为对比的是另一个二维布局 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Grid_Layout">CSS Grid Layout</a>， 可以同时处理行和列上的布局</p>
<h2 id="flexbox-的两个轴线"><a href="#flexbox-的两个轴线" class="headerlink" title="flexbox 的两个轴线"></a>flexbox 的两个轴线</h2><p>当使用 flex 布局时，首先想到的是两根轴线- 主轴和交叉轴。 主轴由 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-direction">flex-direction</a> 定义,另一根轴线垂直于它。我们使用 flexbox 的所有属性都跟这两根轴线有关，所以有必要一开始首先就理解它。</p>
<h3 id="主轴"><a href="#主轴" class="headerlink" title="主轴"></a>主轴</h3><p>主轴由<code>flex-direction</code> 定义, 可以取4个值:</p>
<ul>
<li><code>row</code></li>
<li><code>row-reverse</code></li>
<li><code>column</code></li>
<li><code>column-reverse</code></li>
</ul>
<p>如果你选择了 <code>row</code>或者<code>row-reverse</code>,你的主轴将沿着inline方向延伸。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;-    Main Axis - flex-direction: row  -&gt;</span><br><span class="line">a   b   c</span><br></pre></td></tr></table></figure>
<p>选择<code>column</code> 或者 <code>column-reverse</code> 时，你的主轴会沿着上下方向延伸 – 也就是block 排列的方向。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|      a</span><br><span class="line">|      b</span><br><span class="line">|      c</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="交叉轴"><a href="#交叉轴" class="headerlink" title="交叉轴"></a>交叉轴</h3><p><strong>交叉轴是垂直于主轴的.</strong></p>
<h2 id="起始线和终止线"><a href="#起始线和终止线" class="headerlink" title="起始线和终止线"></a>起始线和终止线</h2><p>另外一个需要理解的重点是 flexbox 不会对文档的书写模式提供假设。过去，css 的书写模式主要被认为是水平的，从左到右的。现代的布局方式涵盖了书写模式的范围，所以我们不再假设一行文字是从文档的左上角开始向右书写，新的行业不是必须出现在另一行的下面。</p>
<h2 id="flex-容器"><a href="#flex-容器" class="headerlink" title="flex 容器"></a>flex 容器</h2><p>文档中采用了 flexbox 的区域就叫做 flex 容器。为了创建 felx容器，我们把一个容器 display 属性值改成 flex 或者 inline-flex。完成这一步后，容器中直系子元素就会变为 flex 元素。所有css属性都会有一个初始值 ，所以 flex容器中的所有flex元素都会有下列行为：</p>
<ul>
<li>元素排列为一行(<code>flex-direction</code>属性的初始值是<code>row</code>)</li>
<li>元素从主轴的起始线开始。</li>
<li>元素不会在主维度方向拉伸，但是可以缩小。</li>
<li>元素被拉伸填充交叉轴大小</li>
<li><code>flex-basis</code>属性为 auto.</li>
<li><code>flex-wrap</code>属性为 nowrap.</li>
</ul>
<p>这会让你的元素呈线性排列，并且把自己的大小作为主轴上的大小。如果有太多元素超出容器，它们会溢出而不会换行。如果一些元素比其他元素高，那么元素沿交叉轴被拉伸来填满它的大小。</p>
<p><a target="_blank" rel="noopener" href="https://codepen.io/zengzhiwei/pen/eYGXvzE">https://codepen.io/zengzhiwei/pen/eYGXvzE</a></p>
<h3 id="更改flex方向-flex-direction"><a href="#更改flex方向-flex-direction" class="headerlink" title="更改flex方向 flex-direction"></a>更改flex方向 flex-direction</h3><p>在 flex 容器中添加 flex-direction 属性可以让我们更改flex 元素的排列方向。设置 <code>flex-direction: row-reverse</code> 可以让元素沿着行的方向显示,但是起始线和终止线会交换.</p>
<p>把flex 容器的属性<code>flex-direction</code>改为<code>column</code>,主轴和交叉轴交换,元素沿着列的方向排列显示。改为<code>column-reverse</code>，起始线和终止线交换。</p>
<p><a target="_blank" rel="noopener" href="https://codepen.io/zengzhiwei/pen/gOGEmWO">https://codepen.io/zengzhiwei/pen/gOGEmWO</a></p>
<h3 id="用-flex-wrap-实现多行flex容器"><a href="#用-flex-wrap-实现多行flex容器" class="headerlink" title="用 flex-wrap  实现多行flex容器"></a>用 flex-wrap  实现多行flex容器</h3><p>虽然<code>flexbox</code>是一维模型，但可以使我们的<code>flex</code>项目应用到多行中。在这样做的时候，您应该把每一行看作一个新的<code>flex</code>容器。任何空间分布都将在该行上发生，而不影响该空间分布的其他行。<br>为了实现多行的效果，请为属性<code>flex-wrap</code>添加一个属性值<code>wrap</code>。</p>
<p><a target="_blank" rel="noopener" href="https://codepen.io/zengzhiwei/pen/qBPvjEq">https://codepen.io/zengzhiwei/pen/qBPvjEq</a></p>
<h3 id="简写属性-flex-flow"><a href="#简写属性-flex-flow" class="headerlink" title="简写属性 flex-flow"></a>简写属性 flex-flow</h3><p>可以将 <code>flex-direction</code>和<code>flex-wrap</code>组合成一个属性<code>flex-flow</code>。第一个指定的值是<code>flex-direction</code>,第二个指定的值为<code>flex-wrap</code></p>
<p><a target="_blank" rel="noopener" href="https://codepen.io/zengzhiwei/pen/poWYwjX">https://codepen.io/zengzhiwei/pen/poWYwjX</a></p>
<h2 id="flex元素上的属性"><a href="#flex元素上的属性" class="headerlink" title="flex元素上的属性"></a>flex元素上的属性</h2><p>为了更好的控制flex元素</p>
<ul>
<li><code>flex-grow</code></li>
<li><code>flex-shrink</code></li>
<li><code>flex-basis</code></li>
</ul>
<p>在考虑这几个属性的作用之前，需要先了解下<strong>可用空间</strong><code>available space</code> 这个概念。这几个flex属性的作用其实就是改变了flex容器中的可用空间的行为。同时，可用空间对于flex元素的对齐行为也是很重要的。</p>
<p>假设再1个500px 的容器中，我们有3个100px 宽的元素，那么这3个元素需要占300px 的宽，剩下 200px 的可用空间。在默认情况下，flexbox的行为会把这200px 的空间留在最后一个元素的后面。</p>
<p><a target="_blank" rel="noopener" href="https://codepen.io/zengzhiwei/pen/abLMwmm">https://codepen.io/zengzhiwei/pen/abLMwmm</a></p>
<p>如果期望这些元素能自动地扩展去填充满剩下的空间，那么我们需要去控制可用空间在这几个元素间如何分配，这就是元素上的那么<code>flex</code>属性要做的事情。</p>
<h3 id="flex-元素属性-flex-basis"><a href="#flex-元素属性-flex-basis" class="headerlink" title="flex 元素属性: flex-basis"></a>flex 元素属性: <code>flex-basis</code></h3><p><code>flex-basis</code> 定义了该元素的<strong>空间大小</strong><code>(the size of that item in terms of the space</code>),flex容器里除了元素所占的空间之外的富余空间就是<strong>可用空间</strong>(<code>available space</code>).该属性的默认值是<code>auto</code>。此时，游览器会检测这个元素是否具有确定的尺寸。在上面的例子中，所有元素都设定了宽度 100px，所以<code>flex-basis</code>的值为100px.</p>
<p>如果没有给元素设定尺寸，<code>flex-basis</code>的值采用元素内容的尺寸。这就解释了：我们只要给Flex元素的父元素声明<code>display: flex;</code>，所有子元素就会排成一行，且自动分配大小以充分展示元素的内容。</p>
<h3 id="flex元素属性-flex-grow"><a href="#flex元素属性-flex-grow" class="headerlink" title="flex元素属性:flex-grow"></a>flex元素属性:<code>flex-grow</code></h3><p><code>flex-grow</code>若被赋值为一个正整数，flex元素会议<code>flex-basis</code>为基础，沿着主轴方向增长尺寸。这会使该元素延展，并占据此方向轴上的可用空间(<code>available space</code>).如果有其他元素也被允许延展，那么他们会各自占据可用空间的一部分。</p>
<p>如果我们给上例中的所有元素设定<code>flex-grow</code>值为1，容器中的可用空间会被这些元素评分。它们会延展以填满容器主轴方向上的空间。<br><code>flex-grow</code>属性可以按比例分配空间。如果第一个元素<code>flex-grow</code>值为2,其他元素值为1,则第一个元素将占有2/4.</p>
<h3 id="flex元素属性：flex-shrink"><a href="#flex元素属性：flex-shrink" class="headerlink" title="flex元素属性：flex-shrink"></a>flex元素属性：<code>flex-shrink</code></h3><p><code>flex-grow</code>属性是处理flex元素在主轴上增加空间的问题，相反<code>flex-shrink</code>属性是处理flex元素收缩的问题。如果我们容器中没有足够排列flex元素的空间，那么可以把flex元素<code>flex-shrink</code>属性设置为正整数来缩小它所占空间到<code>flex-basis</code>以下。与<code>flex-grow</code>属性一样，可以赋予不同的值来控制flex元素收缩的程度—给<code>flex-shrink</code>属性赋予更大的数值可以比赋予小数值的同级元素收缩程度更大。</p>
<p><a target="_blank" rel="noopener" href="https://codepen.io/zengzhiwei/pen/yLzwXpN">https://codepen.io/zengzhiwei/pen/yLzwXpN</a></p>
<h2 id="元素间的对齐和空间分配"><a href="#元素间的对齐和空间分配" class="headerlink" title="元素间的对齐和空间分配"></a>元素间的对齐和空间分配</h2><p>Flexbox的一个关键特性是能够设置flex元素沿着主轴方向和交叉轴方向的对齐方式，以及它们之间的空间分配。</p>
<h3 id="align-item"><a href="#align-item" class="headerlink" title="align-item"></a><code>align-item</code></h3><p><code>align-item</code>属性可以使元素在交叉轴方向对齐<br>这个属性的初始值为<code>stretch</code>，这就是为什么flex元素会默认被拉伸到最高元素的高度。实际上，它们被拉伸来填满flex容器 —- 最高的元素定义了容器的高度。</p>
<p>你也可以设置<code>align-items</code>的值为<code>flex-start</code>,使flex元素按flex容器的顶部对齐，<code>flex-end</code>使它们按flex容器的下部对齐，或者<code>center</code>使它们居中对齐</p>
<p><a target="_blank" rel="noopener" href="https://codepen.io/zengzhiwei/pen/OJxqgoq">https://codepen.io/zengzhiwei/pen/OJxqgoq</a></p>
<h3 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a><code>justify-content</code></h3><p><code>justify-content</code>属性用来使元素在主轴方向上对齐,主轴方向是通过<code>flex-direction</code>设置的方向。初始值是<code>flex-start</code>，元素从容器的起始线排列。但是你也可以把值设置为<code>flex-end</code>，从终止线开始排列，或者<code>center</code>，在中间排列。</p>
<p>你也可以把值设置为<code>space-between</code>,把元素排列好之后的剩余空间拿处理啊，平均分配到元素之间,所以元素之间间隔相等。或者使用<code>space-around</code>，使每个元素的左右空间相等。</p>
<p><a target="_blank" rel="noopener" href="https://codepen.io/zengzhiwei/pen/OJxqgoq">https://codepen.io/zengzhiwei/pen/OJxqgoq</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/01/17/flex/" data-id="cljfboj3300018cb63bu49gs6" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-event-loop" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/01/14/event-loop/" class="article-date">
  <time datetime="2022-01-14T08:23:37.000Z" itemprop="datePublished">2022-01-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/01/14/event-loop/">深入：微任务与JavaScript 运行时环境</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="JavaScript-执行上下文"><a href="#JavaScript-执行上下文" class="headerlink" title="JavaScript 执行上下文"></a>JavaScript 执行上下文</h1><p>当一段 JavaScipt 代码在运行的时候，它实际上运行在执行上下文中。下面3种类型会创建一个新的执行上下文：</p>
<ul>
<li>全局上线爱问是为运行代码主体而创建的执行上下文，也就是说它是为那些存在于JavaScript 函数之外的任何代码而创建的。</li>
<li>每个函数会在执行的时候创建自己的执行上下文。这个上下文就是通常说的“本地上下文”。</li>
<li>使用 eval() 函数也会创建一个新的执行上下文。</li>
</ul>
<p>每一个上下文的本质上都是一种作用域层级。每个代码段开始执行的时候都会创建一个新的上下文来运行它，并且在代码退出的时候销毁掉。</p>
<h1 id="游览器中的事件循环"><a href="#游览器中的事件循环" class="headerlink" title="游览器中的事件循环"></a>游览器中的事件循环</h1><p>每个代理都是由事件循环驱动的，事件循环负责收集用事件（包含用户事件以及其他非用户事件等）、对任务进行排队以便在合适的时候执行回调。然后它执行所有处于等待中的 JavaScript 任务（宏任务） ，然后是 微任务，然后在开始下一次循环之前执行一些必要的渲染和绘制操作。</p>
<p>网页或者app 的代码和游览器本身的用户界面程序运行在相同的线程中，共享相同的事件循环。该线程就是主线程，它除了运行网页本身的代码之外，还负责收集和派发用户和其他事件，以及渲染和绘制网页内容等。</p>
<p>然后，事件循环会驱动发生在游览器中与用户交互有关的一切，但在这里，对我们来说更重要的是需要了解它是如何负责调度和执行在其线程中执行的每段代码的。</p>
<h3 id="Window-事件循环"><a href="#Window-事件循环" class="headerlink" title="Window 事件循环"></a><strong>Window 事件循环</strong></h3><p>  window 事件循环驱动所有同源的窗口</p>
<h3 id="Worker-事件循环"><a href="#Worker-事件循环" class="headerlink" title="Worker 事件循环"></a><strong>Worker 事件循环</strong></h3><p>  worker事件循环顾名思义就是驱动 worker 的事件循环。这包括了所有种类的 worker；最基本的 web worker 以及 shared worker 和 service worker。 Worler 被放在一个或多个独立于“主代码”的代理中。游览器可能会用单个或多个事件循环来处理给定类型的所有 worker。</p>
<h3 id="Worklet-事件循环"><a href="#Worklet-事件循环" class="headerlink" title="Worklet 事件循环"></a><strong>Worklet 事件循环</strong></h3><p>  worklet 事件循环用于驱动运行 worklet 的代理。这包含了 Worklet 、 AudioWorklet 以及 PaintWorklet</p>
<h2 id="（宏任务）-任务-VS-微任务"><a href="#（宏任务）-任务-VS-微任务" class="headerlink" title="（宏任务） 任务 VS 微任务"></a>（宏任务） 任务 VS 微任务</h2><p>一个（宏任务）任务就是指计划由标准机制来执行的任何 javascript， 如程序的初始化、事件触发的回调等。<br>例如： setTimeout 或者 setInterval() 来添加任务</p>
<p>任务队列和微任务队列的区分很简单，但却很重要：</p>
<ul>
<li>当执行来自任务队列中的任务时，在每一次新的事件循环开始迭代的时候运行时都会执行队列中的每个任务。在每次迭代开始之后加入到队列中的任务需要在下一次迭代开始之后才会被执行。</li>
<li>每次当一个任务退出且执行上下文为空的时候，微任务队列中的每一个微任务会依次被执行。不同的是它会等到微任务队列为空才会停止执行—即使中途有微任务加入。换句话说，微任务可以添加新的微任务到队列中，并在下一个任务开始执行之前且当前事件循环结束之前执行完所有的微任务。</li>
</ul>
<p>macro-task 大概包括：</p>
<ul>
<li>script （整体代码）</li>
<li>setTimeout</li>
<li>setInterval</li>
<li>setImmediate</li>
<li>I/O</li>
<li>UI rendermicro-task 大概包括：<ul>
<li>process.nextTick</li>
<li>Promise</li>
<li>Async/Await （实际就是 promise）</li>
<li>MutationObserver （html5 新特性）</li>
</ul>
</li>
</ul>
<p>整体执行</p>
<p>&lt;%- image_tag(‘./../../public/css/images/el1.png’, [options]) %&gt;</p>
<p>总的结论就是,</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/01/14/event-loop/" data-id="cljfboj3d000e8cb67pmmfixr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/01/14/hello-world/" class="article-date">
  <time datetime="2022-01-14T07:40:12.636Z" itemprop="datePublished">2022-01-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/01/14/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/01/14/hello-world/" data-id="cljfboj3600038cb67gz3ayqz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/html/" rel="tag">html</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/node/" rel="tag">node</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/html/" style="font-size: 10px;">html</a> <a href="/tags/node/" style="font-size: 10px;">node</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 10px;">面试</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">三月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">二月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">一月 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/03/15/nodejs-study-day1/">nodejs_study_day1</a>
          </li>
        
          <li>
            <a href="/2022/02/17/interview-01/">interview_01</a>
          </li>
        
          <li>
            <a href="/2022/02/10/2022web%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9801/">2022web前端面试题01</a>
          </li>
        
          <li>
            <a href="/2022/01/21/typescript-day04/">typescript-day04</a>
          </li>
        
          <li>
            <a href="/2022/01/18/typescript-day03/">typescript-day03</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2023 zzw<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>